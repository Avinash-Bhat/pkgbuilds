diff -Npaur a/src/pacman/callback.c b/src/pacman/callback.c
--- a/src/pacman/callback.c	2012-02-03 01:19:15.000000000 +0200
+++ b/src/pacman/callback.c	2012-04-11 18:51:00.943480571 +0300
@@ -221,16 +221,16 @@ void cb_event(alpm_event_t event, void *
 			printf(_("generating %s with %s... "), (char *)data1, (char *)data2);
 			break;
 		case ALPM_EVENT_DELTA_PATCH_DONE:
-			printf(_("success!\n"));
+			color_printf(COLOR_GREEN_ALL, _("success!\n"));
 			break;
 		case ALPM_EVENT_DELTA_PATCH_FAILED:
-			printf(_("failed.\n"));
+			color_printf(COLOR_RED_ALL, _("failed.\n"));
 			break;
 		case ALPM_EVENT_SCRIPTLET_INFO:
 			printf("%s", (char *)data1);
 			break;
 		case ALPM_EVENT_RETRIEVE_START:
-			printf(_(":: Retrieving packages from %s...\n"), (char *)data1);
+			color_printf(COLOR_DOUBLECOLON, _(":: Retrieving packages from %s...\n"), (char *)data1);
 			break;
 		case ALPM_EVENT_DISKSPACE_START:
 			if(config->noprogressbar) {
@@ -264,14 +264,14 @@ void cb_question(alpm_question_t event,
 	switch(event) {
 		case ALPM_QUESTION_INSTALL_IGNOREPKG:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s is in IgnorePkg/IgnoreGroup. Install anyway?"),
 								  alpm_pkg_get_name(data1));
 			} else {
 				*response = 1;
 			}
 			break;
 		case ALPM_QUESTION_REPLACE_PKG:
-			*response = yesno(_(":: Replace %s with %s/%s?"),
+			*response = yesno(COLOR_DOUBLECOLON, _(":: Replace %s with %s/%s?"),
 					alpm_pkg_get_name(data1),
 					(char *)data3,
 					alpm_pkg_get_name(data2));
@@ -280,12 +280,12 @@ void cb_question(alpm_question_t event,
 			/* data parameters: target package, local package, conflict (strings) */
 			/* print conflict only if it contains new information */
 			if(strcmp(data1, data3) == 0 || strcmp(data2, data3) == 0) {
-				*response = noyes(_(":: %s and %s are in conflict. Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict. Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data2);
 			} else {
-				*response = noyes(_(":: %s and %s are in conflict (%s). Remove %s?"),
+				*response = noyes(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s). Remove %s?"),
 						(char *)data1,
 						(char *)data2,
 						(char *)data3,
@@ -302,13 +302,13 @@ void cb_question(alpm_question_t event,
 							(char *)alpm_pkg_get_name(i->data));
 					count++;
 				}
-				printf(_n(
+				color_printf(COLOR_DOUBLECOLON, _n(
 							":: The following package cannot be upgraded due to unresolvable dependencies:\n",
 							":: The following packages cannot be upgraded due to unresolvable dependencies:\n",
 							count));
-				list_display("     ", namelist);
+				list_display(NULL, "     ", namelist);
 				printf("\n");
-				*response = noyes(_n(
+				*response = noyes(NULL, _n(
 							"Do you want to skip the above package for this upgrade?",
 							"Do you want to skip the above packages for this upgrade?",
 							count));
@@ -320,7 +320,7 @@ void cb_question(alpm_question_t event,
 				alpm_list_t *providers = (alpm_list_t *)data1;
 				size_t count = alpm_list_count(providers);
 				char *depstring = alpm_dep_compute_string((alpm_depend_t *)data2);
-				printf(_(":: There are %zd providers available for %s:\n"), count,
+				color_printf(COLOR_DOUBLECOLON, _(":: There are %zd providers available for %s:\n"), count,
 						depstring);
 				free(depstring);
 				select_display(providers);
@@ -329,7 +329,7 @@ void cb_question(alpm_question_t event,
 			break;
 		case ALPM_QUESTION_LOCAL_NEWER:
 			if(!config->op_s_downloadonly) {
-				*response = yesno(_(":: %s-%s: local version is newer. Upgrade anyway?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: %s-%s: local version is newer. Upgrade anyway?"),
 						alpm_pkg_get_name(data1),
 						alpm_pkg_get_version(data1));
 			} else {
@@ -337,7 +337,7 @@ void cb_question(alpm_question_t event,
 			}
 			break;
 		case ALPM_QUESTION_CORRUPTED_PKG:
-			*response = yesno(_(":: File %s is corrupted (%s).\n"
+			*response = yesno(COLOR_DOUBLECOLON, _(":: File %s is corrupted (%s).\n"
 						"Do you want to delete it?"),
 					(char *)data1,
 					alpm_strerror(*(enum _alpm_errno_t *)data2));
@@ -347,7 +347,7 @@ void cb_question(alpm_question_t event,
 				alpm_pgpkey_t *key = data1;
 				char created[12];
 				strftime(created, 12, "%Y-%m-%d", localtime(&(key->created)));
-				*response = yesno(_(":: Import PGP key %s, \"%s\", created %s?"),
+				*response = yesno(COLOR_DOUBLECOLON, _(":: Import PGP key %s, \"%s\", created %s?"),
 						key->fingerprint, key->uid, created);
 			}
 			break;
@@ -481,8 +481,9 @@ void cb_progress(alpm_progress_t event,
 
 	}
 
-	printf("(%*ld/%*ld) %ls%-*s", digits, (unsigned long)current,
-			digits, (unsigned long)howmany, wcstr, padwid, "");
+	color_printf(COLOR_BLUE_ALL, "(%*ld/%*ld)", digits, (unsigned long)current,
+			digits, (unsigned long)howmany);
+	printf(" %ls%-*s", wcstr, padwid, "");
 
 	free(wcstr);
 
diff -Npaur a/src/pacman/package.c b/src/pacman/package.c
--- a/src/pacman/package.c	2012-02-03 01:18:52.000000000 +0200
+++ b/src/pacman/package.c	2012-04-11 18:51:00.944480580 +0300
@@ -41,7 +41,7 @@
  * @param deps a list with items of type alpm_depend_t
  * @return a string list, must be freed
  */
-static void deplist_display(const char *title,
+static void deplist_display(const colordata_t *colors_title, const char *title,
 		alpm_list_t *deps)
 {
 	alpm_list_t *i, *text = NULL;
@@ -49,7 +49,7 @@ static void deplist_display(const char *
 		alpm_depend_t *dep = alpm_list_getdata(i);
 		text = alpm_list_add(text, alpm_dep_compute_string(dep));
 	}
-	list_display(title, text);
+	list_display(colors_title, title, text);
 	FREELIST(text);
 }
 
@@ -102,65 +102,65 @@ void dump_pkg_full(alpm_pkg_t *pkg, int
 
 	/* actual output */
 	if(from == PKG_FROM_SYNCDB) {
-		string_display(_("Repository     :"),
-				alpm_db_get_name(alpm_pkg_get_db(pkg)));
+		color_string_display(COLOR_WHITE_ALL, _("Repository     :"),
+				COLOR_MAGENTA_ALL, alpm_db_get_name(alpm_pkg_get_db(pkg)));
 	}
-	string_display(_("Name           :"), alpm_pkg_get_name(pkg));
-	string_display(_("Version        :"), alpm_pkg_get_version(pkg));
-	string_display(_("URL            :"), alpm_pkg_get_url(pkg));
-	list_display(_("Licenses       :"), alpm_pkg_get_licenses(pkg));
-	list_display(_("Groups         :"), alpm_pkg_get_groups(pkg));
-	deplist_display(_("Provides       :"), alpm_pkg_get_provides(pkg));
-	deplist_display(_("Depends On     :"), alpm_pkg_get_depends(pkg));
-	list_display_linebreak(_("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Name           :"), COLOR_WHITE_ALL, alpm_pkg_get_name(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("Version        :"), COLOR_GREEN_ALL, alpm_pkg_get_version(pkg));
+	color_string_display(COLOR_WHITE_ALL, _("URL            :"), COLOR_CYAN_ALL, alpm_pkg_get_url(pkg));
+	list_display(COLOR_WHITE_ALL, _("Licenses       :"), alpm_pkg_get_licenses(pkg));
+	list_display(COLOR_WHITE_ALL, _("Groups         :"), alpm_pkg_get_groups(pkg));
+	deplist_display(COLOR_WHITE_ALL, _("Provides       :"), alpm_pkg_get_provides(pkg));
+	deplist_display(COLOR_WHITE_ALL, _("Depends On     :"), alpm_pkg_get_depends(pkg));
+	list_display_linebreak(COLOR_WHITE_ALL, _("Optional Deps  :"), alpm_pkg_get_optdepends(pkg));
 	if(extra || from == PKG_FROM_LOCALDB) {
-		list_display(_("Required By    :"), requiredby);
+		list_display(COLOR_WHITE_ALL, _("Required By    :"), requiredby);
 	}
-	deplist_display(_("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
-	deplist_display(_("Replaces       :"), alpm_pkg_get_replaces(pkg));
+	deplist_display(COLOR_WHITE_ALL, _("Conflicts With :"), alpm_pkg_get_conflicts(pkg));
+	deplist_display(COLOR_WHITE_ALL, _("Replaces       :"), alpm_pkg_get_replaces(pkg));
 
 	size = humanize_size(alpm_pkg_get_size(pkg), 'K', 2, &label);
 	if(from == PKG_FROM_SYNCDB) {
-		printf(_("Download Size  : %6.2f %s\n"), size, label);
+		color_printf(COLOR_WHITE_COLON, _("Download Size  : %6.2f %s\n"), size, label);
 	} else if(from == PKG_FROM_FILE) {
-		printf(_("Compressed Size: %6.2f %s\n"), size, label);
+		color_printf(COLOR_WHITE_COLON, _("Compressed Size: %6.2f %s\n"), size, label);
 	}
 
 	size = humanize_size(alpm_pkg_get_isize(pkg), 'K', 2, &label);
-	printf(_("Installed Size : %6.2f %s\n"), size, label);
+	color_printf(COLOR_WHITE_COLON, _("Installed Size : %6.2f %s\n"), size, label);
 
-	string_display(_("Packager       :"), alpm_pkg_get_packager(pkg));
-	string_display(_("Architecture   :"), alpm_pkg_get_arch(pkg));
-	string_display(_("Build Date     :"), bdatestr);
+	string_display(COLOR_WHITE_ALL, _("Packager       :"), alpm_pkg_get_packager(pkg));
+	string_display(COLOR_WHITE_ALL, _("Architecture   :"), alpm_pkg_get_arch(pkg));
+	string_display(COLOR_WHITE_ALL, _("Build Date     :"), bdatestr);
 	if(from == PKG_FROM_LOCALDB) {
-		string_display(_("Install Date   :"), idatestr);
-		string_display(_("Install Reason :"), reason);
+		string_display(COLOR_WHITE_ALL, _("Install Date   :"), idatestr);
+		string_display(COLOR_WHITE_ALL, _("Install Reason :"), reason);
 	}
 	if(from == PKG_FROM_FILE || from == PKG_FROM_LOCALDB) {
-		string_display(_("Install Script :"),
+		string_display(COLOR_WHITE_ALL, _("Install Script :"),
 				alpm_pkg_has_scriptlet(pkg) ?  _("Yes") : _("No"));
 	}
 
 	if(from == PKG_FROM_SYNCDB) {
-		string_display(_("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
-		string_display(_("SHA256 Sum     :"), alpm_pkg_get_sha256sum(pkg));
-		string_display(_("Signatures     :"),
+		string_display(COLOR_WHITE_ALL, _("MD5 Sum        :"), alpm_pkg_get_md5sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("SHA256 Sum     :"), alpm_pkg_get_sha256sum(pkg));
+		string_display(COLOR_WHITE_ALL, _("Signatures     :"),
 				alpm_pkg_get_base64_sig(pkg) ? _("Yes") : _("None"));
 	}
 	if(from == PKG_FROM_FILE) {
 		alpm_siglist_t siglist;
 		int err = alpm_pkg_check_pgp_signature(pkg, &siglist);
 		if(err && alpm_errno(config->handle) == ALPM_ERR_SIG_MISSING) {
-			string_display(_("Signatures     :"), _("None"));
+			string_display(COLOR_WHITE_ALL, _("Signatures     :"), _("None"));
 		} else if(err) {
-			string_display(_("Signatures     :"),
+			string_display(COLOR_WHITE_ALL, _("Signatures     :"),
 					alpm_strerror(alpm_errno(config->handle)));
 		} else {
 			signature_display(_("Signatures     :"), &siglist);
 		}
 		alpm_siglist_cleanup(&siglist);
 	}
-	string_display(_("Description    :"), alpm_pkg_get_desc(pkg));
+	string_display(COLOR_WHITE_ALL, _("Description    :"), alpm_pkg_get_desc(pkg));
 
 	/* Print additional package info if info flag passed more than once */
 	if(from == PKG_FROM_LOCALDB && extra) {
@@ -219,7 +219,7 @@ void dump_pkg_backups(alpm_pkg_t *pkg)
 {
 	alpm_list_t *i;
 	const char *root = alpm_option_get_root(config->handle);
-	printf(_("Backup Files:\n"));
+	color_printf(COLOR_WHITE_ALL, _("Backup Files:\n"));
 	if(alpm_pkg_get_backup(pkg)) {
 		/* package has backup files, so print them */
 		for(i = alpm_pkg_get_backup(pkg); i; i = alpm_list_next(i)) {
@@ -252,7 +252,8 @@ void dump_pkg_files(alpm_pkg_t *pkg, int
 	for(i = 0; i < pkgfiles->count; i++) {
 		const alpm_file_t *file = pkgfiles->files + i;
 		if(!quiet) {
-			printf("%s %s%s\n", pkgname, root, file->name);
+			color_printf(COLOR_WHITE_ALL, "%s", pkgname);
+			printf(" %s%s\n", root, file->name);
 		} else {
 			printf("%s%s\n", root, file->name);
 		}
diff -Npaur a/src/pacman/pacman.c b/src/pacman/pacman.c
--- a/src/pacman/pacman.c	2012-02-15 23:57:20.000000000 +0200
+++ b/src/pacman/pacman.c	2012-04-11 18:51:00.944480580 +0300
@@ -219,11 +219,23 @@ static void usage(int op, const char * c
  */
 static void version(void)
 {
+	color_printf(COLOR_YELLOW_ALL, " .--. ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, " .---. ");
+	printf("  Pacman-color v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	color_printf(COLOR_YELLOW_ALL, "/ _.-'");
+	color_printf(COLOR_WHITE_ALL, " .-.  .-");
+	color_printf(COLOR_RED_ALL, "|O O  |");
+	printf("  Copyright (C) 2006-2012 Pacman Development Team\n");
+	color_printf(COLOR_YELLOW_ALL, "\\  '-.");
+	color_printf(COLOR_WHITE_ALL, " '-'  '-");
+	color_printf(COLOR_RED_ALL, "|~~~  |");
+	printf("  Copyright (C) 2002-2006 Judd Vinet\n");
+	color_printf(COLOR_YELLOW_ALL, " '--' ");
+	printf("        ");
+	color_printf(COLOR_RED_ALL, "|.-.-.|");
+	printf("  Colored by vogo <vogo(at)seznam(dot)cz>\n");
 	printf("\n");
-	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
-	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2012 Pacman Development Team\n");
-	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
-	printf(" '--'\n");
 	printf(_("                       This program may be freely redistributed under\n"
 	         "                       the terms of the GNU General Public License.\n"));
 	printf("\n");
@@ -795,6 +807,7 @@ int main(int argc, char *argv[])
 
 	/* init config data */
 	config = config_new();
+	parsecolorconfig();
 
 	/* disable progressbar if the output is redirected */
 	if(!isatty(fileno(stdout))) {
@@ -896,18 +909,18 @@ int main(int argc, char *argv[])
 
 	if(config->verbose > 0) {
 		alpm_list_t *i;
-		printf("Root      : %s\n", alpm_option_get_root(config->handle));
-		printf("Conf File : %s\n", config->configfile);
-		printf("DB Path   : %s\n", alpm_option_get_dbpath(config->handle));
-		printf("Cache Dirs: ");
+		string_display(COLOR_WHITE_ALL, "Root      :", alpm_option_get_root(config->handle));
+		string_display(COLOR_WHITE_ALL, "Conf File :", config->configfile);
+		string_display(COLOR_WHITE_ALL, "DB Path   :", alpm_option_get_dbpath(config->handle));
+		color_printf(COLOR_WHITE_ALL, "Cache Dirs: ");
 		for(i = alpm_option_get_cachedirs(config->handle); i; i = alpm_list_next(i)) {
 			printf("%s  ", (char *)alpm_list_getdata(i));
 		}
 		printf("\n");
-		printf("Lock File : %s\n", alpm_option_get_lockfile(config->handle));
-		printf("Log File  : %s\n", alpm_option_get_logfile(config->handle));
-		printf("GPG Dir   : %s\n", alpm_option_get_gpgdir(config->handle));
-		list_display("Targets   :", pm_targets);
+		string_display(COLOR_WHITE_ALL, "Lock File :", alpm_option_get_lockfile(config->handle));
+		string_display(COLOR_WHITE_ALL, "Log File  :", alpm_option_get_logfile(config->handle));
+		string_display(COLOR_WHITE_ALL, "GPG Dir   :", alpm_option_get_gpgdir(config->handle));
+		list_display(COLOR_WHITE_ALL, "Targets   :", pm_targets);
 	}
 
 	/* Log command line */
diff -Npaur a/src/pacman/pacman.c.orig b/src/pacman/pacman.c.orig
--- a/src/pacman/pacman.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/pacman/pacman.c.orig	2012-04-11 18:50:50.776479963 +0300
@@ -0,0 +1,948 @@
+/*
+ *  pacman.c
+ *
+ *  Copyright (c) 2006-2011 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+/* special handling of package version for GIT */
+#if defined(GIT_VERSION)
+#undef PACKAGE_VERSION
+#define PACKAGE_VERSION GIT_VERSION
+#endif
+
+#include <ctype.h> /* isspace */
+#include <stdlib.h> /* atoi */
+#include <stdio.h>
+#include <ctype.h> /* isspace */
+#include <limits.h>
+#include <getopt.h>
+#include <string.h>
+#include <signal.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/utsname.h> /* uname */
+#include <locale.h> /* setlocale */
+#include <errno.h>
+#if defined(PACMAN_DEBUG) && defined(HAVE_MCHECK_H)
+#include <mcheck.h> /* debug tracing (mtrace) */
+#endif
+
+/* alpm */
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "pacman.h"
+#include "util.h"
+#include "conf.h"
+
+/* list of targets specified on command line */
+static alpm_list_t *pm_targets;
+
+/* Used to sort the options in --help */
+static int options_cmp(const void *p1, const void *p2)
+{
+	const char *s1 = p1;
+	const char *s2 = p2;
+
+	if(s1 == s2) return 0;
+	if(!s1) return -1;
+	if(!s2) return 1;
+	/* First skip all spaces in both strings */
+	while(isspace((unsigned char)*s1)) {
+		s1++;
+	}
+	while(isspace((unsigned char)*s2)) {
+		s2++;
+	}
+	/* If we compare a long option (--abcd) and a short one (-a),
+	 * the short one always wins */
+	if(*s1 == '-' && *s2 == '-') {
+		s1++;
+		s2++;
+		if(*s1 == '-' && *s2 == '-') {
+			/* two long -> strcmp */
+			s1++;
+			s2++;
+		} else if(*s2 == '-') {
+			/* s1 short, s2 long */
+			return -1;
+		} else if(*s1 == '-') {
+			/* s1 long, s2 short */
+			return 1;
+		}
+		/* two short -> strcmp */
+	}
+
+	return strcmp(s1, s2);
+}
+
+/** Display usage/syntax for the specified operation.
+ * @param op     the operation code requested
+ * @param myname basename(argv[0])
+ */
+static void usage(int op, const char * const myname)
+{
+#define addlist(s) (list = alpm_list_add(list, s))
+	alpm_list_t *list = NULL, *i;
+	/* prefetch some strings for usage below, which moves a lot of calls
+	 * out of gettext. */
+	char const * const str_opt = _("options");
+	char const * const str_file = _("file(s)");
+	char const * const str_pkg = _("package(s)");
+	char const * const str_usg = _("usage");
+	char const * const str_opr = _("operation");
+
+	/* please limit your strings to 80 characters in width */
+	if(op == PM_OP_MAIN) {
+		printf("%s:  %s <%s> [...]\n", str_usg, myname, str_opr);
+		printf(_("operations:\n"));
+		printf("    %s {-h --help}\n", myname);
+		printf("    %s {-V --version}\n", myname);
+		printf("    %s {-D --database} <%s> <%s>\n", myname, str_opt, str_pkg);
+		printf("    %s {-Q --query}    [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-R --remove}   [%s] <%s>\n", myname, str_opt, str_pkg);
+		printf("    %s {-S --sync}     [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-T --deptest}  [%s] [%s]\n", myname, str_opt, str_pkg);
+		printf("    %s {-U --upgrade}  [%s] <%s>\n", myname, str_opt, str_file);
+		printf(_("\nuse '%s {-h --help}' with an operation for available options\n"),
+				myname);
+	} else {
+		if(op == PM_OP_REMOVE) {
+			printf("%s:  %s {-R --remove} [%s] <%s>\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --cascade        remove packages and all packages that depend on them\n"));
+			addlist(_("  -n, --nosave         remove configuration files\n"));
+			addlist(_("  -s, --recursive      remove unnecessary dependencies\n"
+			          "                       (-ss includes explicitly installed dependencies)\n"));
+			addlist(_("  -u, --unneeded       remove unneeded packages\n"));
+		} else if(op == PM_OP_UPGRADE) {
+			printf("%s:  %s {-U --upgrade} [%s] <%s>\n", str_usg, myname, str_opt, str_file);
+			addlist(_("      --needed         do not reinstall up to date packages\n"));
+			printf("%s:\n", str_opt);
+		} else if(op == PM_OP_QUERY) {
+			printf("%s:  %s {-Q --query} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --changelog      view the changelog of a package\n"));
+			addlist(_("  -d, --deps           list packages installed as dependencies [filter]\n"));
+			addlist(_("  -e, --explicit       list packages explicitly installed [filter]\n"));
+			addlist(_("  -g, --groups         view all members of a package group\n"));
+			addlist(_("  -i, --info           view package information (-ii for backup files)\n"));
+			addlist(_("  -k, --check          check that the files owned by the package(s) are present\n"));
+			addlist(_("  -l, --list           list the contents of the queried package\n"));
+			addlist(_("  -m, --foreign        list installed packages not found in sync db(s) [filter]\n"));
+			addlist(_("  -o, --owns <file>    query the package that owns <file>\n"));
+			addlist(_("  -p, --file <package> query a package file instead of the database\n"));
+			addlist(_("  -q, --quiet          show less information for query and search\n"));
+			addlist(_("  -s, --search <regex> search locally-installed packages for matching strings\n"));
+			addlist(_("  -t, --unrequired     list packages not required by any package [filter]\n"));
+			addlist(_("  -u, --upgrades       list outdated packages [filter]\n"));
+		} else if(op == PM_OP_SYNC) {
+			printf("%s:  %s {-S --sync} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("  -c, --clean          remove old packages from cache directory (-cc for all)\n"));
+			addlist(_("  -g, --groups         view all members of a package group\n"));
+			addlist(_("  -i, --info           view package information\n"));
+			addlist(_("  -l, --list <repo>    view a list of packages in a repo\n"));
+			addlist(_("  -q, --quiet          show less information for query and search\n"));
+			addlist(_("  -s, --search <regex> search remote repositories for matching strings\n"));
+			addlist(_("  -u, --sysupgrade     upgrade installed packages (-uu allows downgrade)\n"));
+			addlist(_("  -w, --downloadonly   download packages but do not install/upgrade anything\n"));
+			addlist(_("  -y, --refresh        download fresh package databases from the server\n"));
+			addlist(_("      --needed         do not reinstall up to date packages\n"));
+		} else if(op == PM_OP_DATABASE) {
+			printf("%s:  %s {-D --database} <%s> <%s>\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+			addlist(_("      --asdeps         mark packages as non-explicitly installed\n"));
+			addlist(_("      --asexplicit     mark packages as explicitly installed\n"));
+		} else if(op == PM_OP_DEPTEST) {
+			printf("%s:  %s {-T --deptest} [%s] [%s]\n", str_usg, myname, str_opt, str_pkg);
+			printf("%s:\n", str_opt);
+		}
+		switch(op) {
+			case PM_OP_SYNC:
+			case PM_OP_UPGRADE:
+				addlist(_("  -f, --force          force install, overwrite conflicting files\n"));
+				addlist(_("      --asdeps         install packages as non-explicitly installed\n"));
+				addlist(_("      --asexplicit     install packages as explicitly installed\n"));
+				addlist(_("      --ignore <pkg>   ignore a package upgrade (can be used more than once)\n"));
+				addlist(_("      --ignoregroup <grp>\n"
+				          "                       ignore a group upgrade (can be used more than once)\n"));
+				/* pass through */
+			case PM_OP_REMOVE:
+				addlist(_("  -d, --nodeps         skip dependency version checks (-dd to skip all checks)\n"));
+				addlist(_("      --dbonly         only modify database entries, not package files\n"));
+				addlist(_("      --noprogressbar  do not show a progress bar when downloading files\n"));
+				addlist(_("      --noscriptlet    do not execute the install scriptlet if one exists\n"));
+				addlist(_("  -p, --print          print the targets instead of performing the operation\n"));
+				addlist(_("      --print-format <string>\n"
+				          "                       specify how the targets should be printed\n"));
+				break;
+		}
+
+		addlist(_("  -b, --dbpath <path>  set an alternate database location\n"));
+		addlist(_("  -r, --root <path>    set an alternate installation root\n"));
+		addlist(_("  -v, --verbose        be verbose\n"));
+		addlist(_("      --arch <arch>    set an alternate architecture\n"));
+		addlist(_("      --cachedir <dir> set an alternate package cache location\n"));
+		addlist(_("      --config <path>  set an alternate configuration file\n"));
+		addlist(_("      --debug          display debug messages\n"));
+		addlist(_("      --gpgdir <path>  set an alternate home directory for GnuPG\n"));
+		addlist(_("      --logfile <path> set an alternate log file\n"));
+		addlist(_("      --noconfirm      do not ask for any confirmation\n"));
+	}
+	list = alpm_list_msort(list, alpm_list_count(list), options_cmp);
+	for (i = list; i; i = alpm_list_next(i)) {
+		printf("%s", (char *)alpm_list_getdata(i));
+	}
+	alpm_list_free(list);
+#undef addlist
+}
+
+/** Output pacman version and copyright.
+ */
+static void version(void)
+{
+	printf("\n");
+	printf(" .--.                  Pacman v%s - libalpm v%s\n", PACKAGE_VERSION, alpm_version());
+	printf("/ _.-' .-.  .-.  .-.   Copyright (C) 2006-2012 Pacman Development Team\n");
+	printf("\\  '-. '-'  '-'  '-'   Copyright (C) 2002-2006 Judd Vinet\n");
+	printf(" '--'\n");
+	printf(_("                       This program may be freely redistributed under\n"
+	         "                       the terms of the GNU General Public License.\n"));
+	printf("\n");
+}
+
+/** Sets up gettext localization. Safe to call multiple times.
+ */
+/* Inspired by the monotone function localize_monotone. */
+#if defined(ENABLE_NLS)
+static void localize(void)
+{
+	static int init = 0;
+	if(!init) {
+		setlocale(LC_ALL, "");
+		bindtextdomain(PACKAGE, LOCALEDIR);
+		textdomain(PACKAGE);
+		init = 1;
+	}
+}
+#endif
+
+/** Set user agent environment variable.
+ */
+static void setuseragent(void)
+{
+	char agent[101];
+	struct utsname un;
+
+	uname(&un);
+	snprintf(agent, 100, "pacman/%s (%s %s) libalpm/%s",
+			PACKAGE_VERSION, un.sysname, un.machine, alpm_version());
+	setenv("HTTP_USER_AGENT", agent, 0);
+}
+
+/** Free the resources.
+ *
+ * @param ret the return value
+ */
+static void cleanup(int ret) {
+	/* free alpm library resources */
+	if(config->handle && alpm_release(config->handle) == -1) {
+		pm_printf(ALPM_LOG_ERROR, "error releasing alpm library\n");
+	}
+
+	/* free memory */
+	FREELIST(pm_targets);
+	if(config) {
+		config_free(config);
+		config = NULL;
+	}
+
+	exit(ret);
+}
+
+/** Write function that correctly handles EINTR.
+ */
+static ssize_t xwrite(int fd, const void *buf, size_t count)
+{
+	ssize_t ret;
+	do {
+		ret = write(fd, buf, count);
+	} while(ret == -1 && errno == EINTR);
+	return ret;
+}
+
+/** Catches thrown signals. Performs necessary cleanup to ensure database is
+ * in a consistant state.
+ * @param signum the thrown signal
+ */
+static void handler(int signum)
+{
+	int out = fileno(stdout);
+	int err = fileno(stderr);
+	const char *msg;
+	if(signum == SIGSEGV) {
+		msg = "\nerror: segmentation fault\n"
+			"Please submit a full bug report with --debug if appropriate.\n";
+		xwrite(err, msg, strlen(msg));
+		exit(signum);
+	} else if(signum == SIGINT || signum == SIGHUP) {
+		if(signum == SIGINT) {
+			msg = "\nInterrupt signal received\n";
+		} else {
+			msg = "\nHangup signal received\n";
+		}
+		xwrite(err, msg, strlen(msg));
+		if(alpm_trans_interrupt(config->handle) == 0) {
+			/* a transaction is being interrupted, don't exit pacman yet. */
+			return;
+		}
+	}
+	/* SIGINT: no commiting transaction, release it now and then exit pacman
+	 * SIGHUP, SIGTERM: release no matter what */
+	alpm_trans_release(config->handle);
+	/* output a newline to be sure we clear any line we may be on */
+	xwrite(out, "\n", 1);
+	cleanup(128 + signum);
+}
+
+#define check_optarg() if(!optarg) { return 1; }
+
+static int parsearg_util_addlist(alpm_list_t **list)
+{
+	alpm_list_t *split, *item;
+
+	check_optarg();
+	split = strsplit(optarg, ',');
+	for(item = split; item; item = alpm_list_next(item)) {
+		*list = alpm_list_add(*list, item->data);
+	}
+	alpm_list_free(split);
+	return 0;
+}
+
+/** Helper function for parsing operation from command-line arguments.
+ * @param opt Keycode returned by getopt_long
+ * @param dryrun If nonzero, application state is NOT changed
+ * @return 0 if opt was handled, 1 if it was not handled
+ */
+static int parsearg_op(int opt, int dryrun)
+{
+	switch(opt) {
+		/* operations */
+		case 'D':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_DATABASE); break;
+		case 'Q':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_QUERY); break;
+		case 'R':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_REMOVE); break;
+		case 'S':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_SYNC); break;
+		case 'T':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_DEPTEST); break;
+		case 'U':
+			if(dryrun) break;
+			config->op = (config->op != PM_OP_MAIN ? 0 : PM_OP_UPGRADE); break;
+		case 'V':
+			if(dryrun) break;
+			config->version = 1; break;
+		case 'h':
+			if(dryrun) break;
+			config->help = 1; break;
+		default:
+			return 1;
+	}
+	return 0;
+}
+
+/** Helper functions for parsing command-line arguments.
+ * @param opt Keycode returned by getopt_long
+ * @return 0 on success, 1 on failure
+ */
+static int parsearg_global(int opt)
+{
+	switch(opt) {
+		case OP_ARCH:
+			check_optarg();
+			config_set_arch(optarg);
+			break;
+		case OP_ASK:
+			check_optarg();
+			config->noask = 1;
+			config->ask = (unsigned int)atoi(optarg);
+			break;
+		case OP_CACHEDIR:
+			check_optarg();
+			config->cachedirs = alpm_list_add(config->cachedirs, strdup(optarg));
+			break;
+		case OP_CONFIG:
+			check_optarg();
+			if(config->configfile) {
+				free(config->configfile);
+			}
+			config->configfile = strndup(optarg, PATH_MAX);
+			break;
+		case OP_DEBUG:
+			/* debug levels are made more 'human readable' than using a raw logmask
+			 * here, error and warning are set in config_new, though perhaps a
+			 * --quiet option will remove these later */
+			if(optarg) {
+				unsigned short debug = (unsigned short)atoi(optarg);
+				switch(debug) {
+					case 2:
+						config->logmask |= ALPM_LOG_FUNCTION; /* fall through */
+					case 1:
+						config->logmask |= ALPM_LOG_DEBUG;
+						break;
+					default:
+						pm_printf(ALPM_LOG_ERROR, _("'%s' is not a valid debug level\n"),
+								optarg);
+						return 1;
+				}
+			} else {
+				config->logmask |= ALPM_LOG_DEBUG;
+			}
+			/* progress bars get wonky with debug on, shut them off */
+			config->noprogressbar = 1;
+			break;
+		case OP_GPGDIR:
+			config->gpgdir = strdup(optarg);
+			break;
+		case OP_LOGFILE:
+			check_optarg();
+			config->logfile = strndup(optarg, PATH_MAX);
+			break;
+		case OP_NOCONFIRM: config->noconfirm = 1; break;
+		case 'b':
+			check_optarg();
+			config->dbpath = strdup(optarg);
+			break;
+		case 'r': check_optarg(); config->rootdir = strdup(optarg); break;
+		case 'v': (config->verbose)++; break;
+		default: return 1;
+	}
+	return 0;
+}
+
+static int parsearg_database(int opt)
+{
+	switch(opt) {
+		case OP_ASDEPS: config->flags |= ALPM_TRANS_FLAG_ALLDEPS; break;
+		case OP_ASEXPLICIT: config->flags |= ALPM_TRANS_FLAG_ALLEXPLICIT; break;
+		default: return 1;
+	}
+	return 0;
+}
+
+static int parsearg_query(int opt)
+{
+	switch(opt) {
+		case 'c': config->op_q_changelog = 1; break;
+		case 'd': config->op_q_deps = 1; break;
+		case 'e': config->op_q_explicit = 1; break;
+		case 'g': (config->group)++; break;
+		case 'i': (config->op_q_info)++; break;
+		case 'k': config->op_q_check = 1; break;
+		case 'l': config->op_q_list = 1; break;
+		case 'm': config->op_q_foreign = 1; break;
+		case 'o': config->op_q_owns = 1; break;
+		case 'p': config->op_q_isfile = 1; break;
+		case 'q': config->quiet = 1; break;
+		case 's': config->op_q_search = 1; break;
+		case 't': config->op_q_unrequired = 1; break;
+		case 'u': config->op_q_upgrade = 1; break;
+		default: return 1;
+	}
+	return 0;
+}
+
+/* options common to -S -R -U */
+static int parsearg_trans(int opt)
+{
+	switch(opt) {
+		case 'd':
+			if(config->flags & ALPM_TRANS_FLAG_NODEPVERSION) {
+				config->flags |= ALPM_TRANS_FLAG_NODEPS;
+			} else {
+				config->flags |= ALPM_TRANS_FLAG_NODEPVERSION;
+			}
+			break;
+		case OP_DBONLY: config->flags |= ALPM_TRANS_FLAG_DBONLY; break;
+		case OP_NOPROGRESSBAR: config->noprogressbar = 1; break;
+		case OP_NOSCRIPTLET: config->flags |= ALPM_TRANS_FLAG_NOSCRIPTLET; break;
+		case 'p': config->print = 1; break;
+		case OP_PRINTFORMAT:
+			check_optarg();
+			config->print_format = strdup(optarg);
+			break;
+		default: return 1;
+	}
+	return 0;
+}
+
+static int parsearg_remove(int opt)
+{
+	if(parsearg_trans(opt) == 0)
+		return 0;
+	switch(opt) {
+		case 'c': config->flags |= ALPM_TRANS_FLAG_CASCADE; break;
+		case 'n': config->flags |= ALPM_TRANS_FLAG_NOSAVE; break;
+		case 's':
+			if(config->flags & ALPM_TRANS_FLAG_RECURSE) {
+				config->flags |= ALPM_TRANS_FLAG_RECURSEALL;
+			} else {
+				config->flags |= ALPM_TRANS_FLAG_RECURSE;
+			}
+			break;
+		case 'u': config->flags |= ALPM_TRANS_FLAG_UNNEEDED; break;
+		default: return 1;
+	}
+	return 0;
+}
+
+/* options common to -S -U */
+static int parsearg_upgrade(int opt)
+{
+	if(parsearg_trans(opt) == 0)
+		return 0;
+	switch(opt) {
+		case 'f': config->flags |= ALPM_TRANS_FLAG_FORCE; break;
+		case OP_ASDEPS: config->flags |= ALPM_TRANS_FLAG_ALLDEPS; break;
+		case OP_ASEXPLICIT: config->flags |= ALPM_TRANS_FLAG_ALLEXPLICIT; break;
+		case OP_NEEDED: config->flags |= ALPM_TRANS_FLAG_NEEDED; break;
+		case OP_IGNORE:
+			parsearg_util_addlist(&(config->ignorepkg));
+			break;
+		case OP_IGNOREGROUP:
+			parsearg_util_addlist(&(config->ignoregrp));
+			break;
+		default: return 1;
+	}
+	return 0;
+}
+
+static int parsearg_sync(int opt)
+{
+	if(parsearg_upgrade(opt) == 0)
+		return 0;
+	switch(opt) {
+		case 'c': (config->op_s_clean)++; break;
+		case 'g': (config->group)++; break;
+		case 'i': (config->op_s_info)++; break;
+		case 'l': config->op_q_list = 1; break;
+		case 'q': config->quiet = 1; break;
+		case 's': config->op_s_search = 1; break;
+		case 'u': (config->op_s_upgrade)++; break;
+		case 'w':
+			config->op_s_downloadonly = 1;
+			config->flags |= ALPM_TRANS_FLAG_DOWNLOADONLY;
+			config->flags |= ALPM_TRANS_FLAG_NOCONFLICTS;
+			break;
+		case 'y': (config->op_s_sync)++; break;
+		default: return 1;
+	}
+	return 0;
+}
+
+/** Parse command-line arguments for each operation.
+ * @param argc argc
+ * @param argv argv
+ * @return 0 on success, 1 on error
+ */
+static int parseargs(int argc, char *argv[])
+{
+	int opt;
+	int option_index = 0;
+	int result;
+	const char *optstring = "DQRSTUVb:cdefghiklmnopqr:stuvwy";
+	static const struct option opts[] =
+	{
+		{"database",   no_argument,       0, 'D'},
+		{"query",      no_argument,       0, 'Q'},
+		{"remove",     no_argument,       0, 'R'},
+		{"sync",       no_argument,       0, 'S'},
+		{"deptest",    no_argument,       0, 'T'}, /* used by makepkg */
+		{"upgrade",    no_argument,       0, 'U'},
+		{"version",    no_argument,       0, 'V'},
+		{"dbpath",     required_argument, 0, 'b'},
+		{"cascade",    no_argument,       0, 'c'},
+		{"changelog",  no_argument,       0, 'c'},
+		{"clean",      no_argument,       0, 'c'},
+		{"nodeps",     no_argument,       0, 'd'},
+		{"deps",       no_argument,       0, 'd'},
+		{"explicit",   no_argument,       0, 'e'},
+		{"force",      no_argument,       0, 'f'},
+		{"groups",     no_argument,       0, 'g'},
+		{"help",       no_argument,       0, 'h'},
+		{"info",       no_argument,       0, 'i'},
+		{"check",      no_argument,       0, 'k'},
+		{"list",       no_argument,       0, 'l'},
+		{"foreign",    no_argument,       0, 'm'},
+		{"nosave",     no_argument,       0, 'n'},
+		{"owns",       no_argument,       0, 'o'},
+		{"file",       no_argument,       0, 'p'},
+		{"print",      no_argument,       0, 'p'},
+		{"quiet",      no_argument,       0, 'q'},
+		{"root",       required_argument, 0, 'r'},
+		{"recursive",  no_argument,       0, 's'},
+		{"search",     no_argument,       0, 's'},
+		{"unrequired", no_argument,       0, 't'},
+		{"upgrades",   no_argument,       0, 'u'},
+		{"sysupgrade", no_argument,       0, 'u'},
+		{"unneeded",   no_argument,       0, 'u'},
+		{"verbose",    no_argument,       0, 'v'},
+		{"downloadonly", no_argument,     0, 'w'},
+		{"refresh",    no_argument,       0, 'y'},
+
+		{"noconfirm",  no_argument,       0, OP_NOCONFIRM},
+		{"config",     required_argument, 0, OP_CONFIG},
+		{"ignore",     required_argument, 0, OP_IGNORE},
+		{"debug",      optional_argument, 0, OP_DEBUG},
+		{"noprogressbar", no_argument,    0, OP_NOPROGRESSBAR},
+		{"noscriptlet", no_argument,      0, OP_NOSCRIPTLET},
+		{"ask",        required_argument, 0, OP_ASK},
+		{"cachedir",   required_argument, 0, OP_CACHEDIR},
+		{"asdeps",     no_argument,       0, OP_ASDEPS},
+		{"logfile",    required_argument, 0, OP_LOGFILE},
+		{"ignoregroup", required_argument, 0, OP_IGNOREGROUP},
+		{"needed",     no_argument,       0, OP_NEEDED},
+		{"asexplicit",     no_argument,   0, OP_ASEXPLICIT},
+		{"arch",       required_argument, 0, OP_ARCH},
+		{"print-format", required_argument, 0, OP_PRINTFORMAT},
+		{"gpgdir",     required_argument, 0, OP_GPGDIR},
+		{"dbonly",     no_argument,       0, OP_DBONLY},
+		{0, 0, 0, 0}
+	};
+
+	/* parse operation */
+	while((opt = getopt_long(argc, argv, optstring, opts, &option_index))) {
+		if(opt < 0) {
+			break;
+		} else if(opt == 0) {
+			continue;
+		} else if(opt == '?') {
+			/* unknown option, getopt printed an error */
+			return 1;
+		}
+		parsearg_op(opt, 0);
+	}
+
+	if(config->op == 0) {
+		pm_printf(ALPM_LOG_ERROR, _("only one operation may be used at a time\n"));
+		return 1;
+	}
+	if(config->help) {
+		usage(config->op, mbasename(argv[0]));
+		return 2;
+	}
+	if(config->version) {
+		version();
+		return 2;
+	}
+
+	/* parse all other options */
+	optind = 1;
+	while((opt = getopt_long(argc, argv, optstring, opts, &option_index))) {
+		if(opt < 0) {
+			break;
+		} else if(opt == 0) {
+			continue;
+		} else if(opt == '?') {
+			/* this should have failed during first pass already */
+			return 1;
+		} else if(parsearg_op(opt, 1) == 0) {
+			/* opt is an operation */
+			continue;
+		}
+
+		switch(config->op) {
+			case PM_OP_DATABASE:
+				result = parsearg_database(opt);
+				break;
+			case PM_OP_QUERY:
+				result = parsearg_query(opt);
+				break;
+			case PM_OP_REMOVE:
+				result = parsearg_remove(opt);
+				break;
+			case PM_OP_SYNC:
+				result = parsearg_sync(opt);
+				break;
+			case PM_OP_UPGRADE:
+				result = parsearg_upgrade(opt);
+				break;
+			case PM_OP_DEPTEST:
+			default:
+				result = 1;
+				break;
+		}
+		if(result == 0) {
+			continue;
+		}
+
+		/* fall back to global options */
+		result = parsearg_global(opt);
+		if(result != 0) {
+			/* global option parsing failed, abort */
+			pm_printf(ALPM_LOG_ERROR, _("invalid option\n"));
+			return result;
+		}
+	}
+
+	while(optind < argc) {
+		/* add the target to our target array */
+		pm_targets = alpm_list_add(pm_targets, strdup(argv[optind]));
+		optind++;
+	}
+
+	return 0;
+}
+
+/** Print command line to logfile.
+ * @param argc
+ * @param argv
+ */
+static void cl_to_log(int argc, char* argv[])
+{
+	size_t size = 0;
+	int i;
+	for(i = 0; i < argc; i++) {
+		size += strlen(argv[i]) + 1;
+	}
+	if(!size) {
+		return;
+	}
+	char *cl_text = malloc(size);
+	if(!cl_text) {
+		return;
+	}
+	char *p = cl_text;
+	for(i = 0; i < argc - 1; i++) {
+		strcpy(p, argv[i]);
+		p += strlen(argv[i]);
+		*p++ = ' ';
+	}
+	strcpy(p, argv[i]);
+	alpm_logaction(config->handle, "Running '%s'\n", cl_text);
+	free(cl_text);
+}
+
+/** Main function.
+ * @param argc
+ * @param argv
+ * @return A return code indicating success, failure, etc.
+ */
+int main(int argc, char *argv[])
+{
+	int ret = 0;
+	size_t i;
+	struct sigaction new_action, old_action;
+	const int signals[] = { SIGHUP, SIGINT, SIGTERM, SIGSEGV };
+#if defined(HAVE_GETEUID) && !defined(CYGWIN)
+	/* geteuid undefined in CYGWIN */
+	uid_t myuid = geteuid();
+#endif
+
+#if defined(PACMAN_DEBUG) && defined(HAVE_MCHECK_H)
+	/*setenv("MALLOC_TRACE","pacman.mtrace", 0);*/
+	mtrace();
+#endif
+
+	/* Set signal handlers */
+	/* Set up the structure to specify the new action. */
+	new_action.sa_handler = handler;
+	sigemptyset(&new_action.sa_mask);
+	new_action.sa_flags = 0;
+
+	/* assign our handler to any signals we care about */
+	for(i = 0; i < sizeof(signals) / sizeof(signals[0]); i++) {
+		int signal = signals[i];
+		sigaction(signal, NULL, &old_action);
+		if(old_action.sa_handler != SIG_IGN) {
+			sigaction(signal, &new_action, NULL);
+		}
+	}
+
+	/* i18n init */
+#if defined(ENABLE_NLS)
+	localize();
+#endif
+
+	/* set user agent for downloading */
+	setuseragent();
+
+	/* init config data */
+	config = config_new();
+
+	/* disable progressbar if the output is redirected */
+	if(!isatty(fileno(stdout))) {
+		config->noprogressbar = 1;
+	}
+
+	/* Priority of options:
+	 * 1. command line
+	 * 2. config file
+	 * 3. compiled-in defaults
+	 * However, we have to parse the command line first because a config file
+	 * location can be specified here, so we need to make sure we prefer these
+	 * options over the config file coming second.
+	 */
+
+	/* parse the command line */
+	ret = parseargs(argc, argv);
+	if(ret != 0) {
+		cleanup(ret);
+	}
+
+	/* we support reading targets from stdin if a cmdline parameter is '-' */
+	if(!isatty(fileno(stdin)) && alpm_list_find_str(pm_targets, "-")) {
+		size_t current_size = PATH_MAX, i = 0;
+		char *line = malloc(current_size);
+
+		/* remove the '-' from the list */
+		pm_targets = alpm_list_remove_str(pm_targets, "-", NULL);
+
+		while((line[i] = (char)fgetc(stdin)) != EOF) {
+			if(isspace((unsigned char)line[i])) {
+				/* avoid adding zero length arg when multiple spaces separate args */
+				if(i > 0) {
+					line[i] = '\0';
+					pm_targets = alpm_list_add(pm_targets, strdup(line));
+					i = 0;
+				}
+			} else {
+				i++;
+				/* we may be at the end of our allocated buffer now */
+				if(i >= current_size) {
+					char *new = realloc(line, current_size * 2);
+					if(new) {
+						line = new;
+						current_size *= 2;
+					} else {
+						free(line);
+						line = NULL;
+						break;
+					}
+				}
+			}
+		}
+		/* check for memory exhaustion */
+		if(!line) {
+			pm_printf(ALPM_LOG_ERROR, _("memory exhausted in argument parsing\n"));
+			cleanup(EXIT_FAILURE);
+		}
+
+		/* end of stream -- check for data still in line buffer */
+		if(i > 0) {
+			line[i] = '\0';
+			pm_targets = alpm_list_add(pm_targets, strdup(line));
+		}
+		free(line);
+		if(!freopen(ctermid(NULL), "r", stdin)) {
+			pm_printf(ALPM_LOG_ERROR, _("failed to reopen stdin for reading: (%s)\n"),
+					strerror(errno));
+		}
+	}
+
+	/* parse the config file */
+	ret = parseconfig(config->configfile);
+	if(ret != 0) {
+		cleanup(ret);
+	}
+
+	/* noask is meant to be non-interactive */
+	if(config->noask) {
+		config->noconfirm = 1;
+	}
+
+	/* set up the print operations */
+	if(config->print && !config->op_s_clean) {
+		config->noconfirm = 1;
+		config->flags |= ALPM_TRANS_FLAG_NOCONFLICTS;
+		config->flags |= ALPM_TRANS_FLAG_NOLOCK;
+		/* Display only errors */
+		config->logmask &= ~ALPM_LOG_WARNING;
+	}
+
+#if defined(HAVE_GETEUID) && !defined(CYGWIN)
+	/* check if we have sufficient permission for the requested operation */
+	if(myuid > 0 && needs_root()) {
+		pm_printf(ALPM_LOG_ERROR, _("you cannot perform this operation unless you are root.\n"));
+		cleanup(EXIT_FAILURE);
+	}
+#endif
+
+	if(config->verbose > 0) {
+		alpm_list_t *i;
+		printf("Root      : %s\n", alpm_option_get_root(config->handle));
+		printf("Conf File : %s\n", config->configfile);
+		printf("DB Path   : %s\n", alpm_option_get_dbpath(config->handle));
+		printf("Cache Dirs: ");
+		for(i = alpm_option_get_cachedirs(config->handle); i; i = alpm_list_next(i)) {
+			printf("%s  ", (char *)alpm_list_getdata(i));
+		}
+		printf("\n");
+		printf("Lock File : %s\n", alpm_option_get_lockfile(config->handle));
+		printf("Log File  : %s\n", alpm_option_get_logfile(config->handle));
+		printf("GPG Dir   : %s\n", alpm_option_get_gpgdir(config->handle));
+		list_display("Targets   :", pm_targets);
+	}
+
+	/* Log command line */
+	if(needs_root()) {
+		cl_to_log(argc, argv);
+	}
+
+	/* start the requested operation */
+	switch(config->op) {
+		case PM_OP_DATABASE:
+			ret = pacman_database(pm_targets);
+			break;
+		case PM_OP_REMOVE:
+			ret = pacman_remove(pm_targets);
+			break;
+		case PM_OP_UPGRADE:
+			ret = pacman_upgrade(pm_targets);
+			break;
+		case PM_OP_QUERY:
+			ret = pacman_query(pm_targets);
+			break;
+		case PM_OP_SYNC:
+			ret = pacman_sync(pm_targets);
+			break;
+		case PM_OP_DEPTEST:
+			ret = pacman_deptest(pm_targets);
+			break;
+		default:
+			pm_printf(ALPM_LOG_ERROR, _("no operation specified (use -h for help)\n"));
+			ret = EXIT_FAILURE;
+	}
+
+	cleanup(ret);
+	/* not reached */
+	return EXIT_SUCCESS;
+}
+
+/* vim: set ts=2 sw=2 noet: */
diff -Npaur a/src/pacman/query.c b/src/pacman/query.c
--- a/src/pacman/query.c	2011-12-23 22:36:36.000000000 +0200
+++ b/src/pacman/query.c	2012-04-11 18:51:00.945480590 +0300
@@ -266,7 +266,9 @@ static int query_search(alpm_list_t *tar
 		alpm_pkg_t *pkg = alpm_list_getdata(i);
 
 		if(!config->quiet) {
-			printf("local/%s %s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_MAGENTA_ALL, "local/");
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s", alpm_pkg_get_name(pkg));
 		}
@@ -275,16 +277,11 @@ static int query_search(alpm_list_t *tar
 		if(!config->quiet) {
 			if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 				alpm_list_t *k;
-				printf(" (");
+				color_printf(COLOR_BLUE_ALL, " (");
 				for(k = grp; k; k = alpm_list_next(k)) {
 					const char *group = alpm_list_getdata(k);
-					printf("%s", group);
-					if(alpm_list_next(k)) {
-						/* only print a spacer if there are more groups */
-						printf(" ");
-					}
+					color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 				}
-				printf(")");
 			}
 
 			/* we need a newline and initial indent first */
@@ -315,7 +312,8 @@ static int query_group(alpm_list_t *targ
 
 			for(p = grp->packages; p; p = alpm_list_next(p)) {
 				alpm_pkg_t *pkg = alpm_list_getdata(p);
-				printf("%s %s\n", grp->name, alpm_pkg_get_name(pkg));
+				color_printf(COLOR_BLUE_ALL, "%s ", grp->name);
+				color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(pkg));
 			}
 		}
 	} else {
@@ -327,8 +325,8 @@ static int query_group(alpm_list_t *targ
 				const alpm_list_t *p;
 				for(p = grp->packages; p; p = alpm_list_next(p)) {
 					if(!config->quiet) {
-						printf("%s %s\n", grpname,
-								alpm_pkg_get_name(alpm_list_getdata(p)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					} else {
 						printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(p)));
 					}
@@ -478,7 +476,8 @@ static int display(alpm_pkg_t *pkg)
 	if(!config->op_q_info && !config->op_q_list
 			&& !config->op_q_changelog && !config->op_q_check) {
 		if(!config->quiet) {
-			printf("%s %s\n", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+			color_printf(COLOR_GREEN_ALL, "%s\n", alpm_pkg_get_version(pkg));
 		} else {
 			printf("%s\n", alpm_pkg_get_name(pkg));
 		}
diff -Npaur a/src/pacman/remove.c b/src/pacman/remove.c
--- a/src/pacman/remove.c	2012-02-06 13:36:22.000000000 +0200
+++ b/src/pacman/remove.c	2012-04-11 18:51:00.945480590 +0300
@@ -111,14 +111,14 @@ int pacman_remove(alpm_list_t *targets)
 			case ALPM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case ALPM_ERR_UNSATISFIED_DEPS:
 				for(i = data; i; i = alpm_list_next(i)) {
 					alpm_depmissing_t *miss = alpm_list_getdata(i);
 					char *depstring = alpm_dep_compute_string(miss->depend);
-					printf(_(":: %s: requires %s\n"), miss->target, depstring);
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), miss->target, depstring);
 					free(depstring);
 				}
 				break;
@@ -140,7 +140,7 @@ int pacman_remove(alpm_list_t *targets)
 			holdpkg = 1;
 		}
 	}
-	if(holdpkg && (noyes(_("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
+	if(holdpkg && (noyes(NULL, _("HoldPkg was found in target list. Do you want to continue?")) == 0)) {
 		retval = 1;
 		goto cleanup;
 	}
@@ -160,7 +160,7 @@ int pacman_remove(alpm_list_t *targets)
 	/* print targets and ask user confirmation */
 	display_targets();
 	printf("\n");
-	if(yesno(_("Do you want to remove these packages?")) == 0) {
+	if(yesno(NULL, _("Do you want to remove these packages?")) == 0) {
 		retval = 1;
 		goto cleanup;
 	}
diff -Npaur a/src/pacman/sync.c b/src/pacman/sync.c
--- a/src/pacman/sync.c	2012-03-13 15:24:11.000000000 +0200
+++ b/src/pacman/sync.c	2012-04-11 18:51:00.946480606 +0300
@@ -146,8 +146,8 @@ static int sync_cleandb_all(void)
 	int ret = 0;
 
 	dbpath = alpm_option_get_dbpath(config->handle);
-	printf(_("Database directory: %s\n"), dbpath);
-	if(!yesno(_("Do you want to remove unused repositories?"))) {
+	color_printf(COLOR_WHITE_COLON, _("Database directory: %s\n"), dbpath);
+	if(!yesno(NULL, _("Do you want to remove unused repositories?"))) {
 		return 0;
 	}
 	printf(_("removing unused sync repositories...\n"));
@@ -175,7 +175,7 @@ static int sync_cleancache(int level)
 	int ret = 0;
 
 	for(i = cachedirs; i; i = alpm_list_next(i)) {
-		printf(_("Cache directory: %s\n"), (char *)alpm_list_getdata(i));
+		color_printf(COLOR_WHITE_COLON, _("Cache directory: %s\n"), (char *)alpm_list_getdata(i));
 	}
 
 	if(!config->cleanmethod) {
@@ -184,19 +184,19 @@ static int sync_cleancache(int level)
 	}
 
 	if(level == 1) {
-		printf(_("Packages to keep:\n"));
+		color_printf(COLOR_WHITE_COLON, _("Packages to keep:\n"));
 		if(config->cleanmethod & PM_CLEAN_KEEPINST) {
 			printf(_("  All locally installed packages\n"));
 		}
 		if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
 			printf(_("  All current sync database packages\n"));
 		}
-		if(!yesno(_("Do you want to remove all other packages from cache?"))) {
+		if(!yesno(NULL, _("Do you want to remove all other packages from cache?"))) {
 			return 0;
 		}
 		printf(_("removing old packages from cache...\n"));
 	} else {
-		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+		if(!noyes(NULL, _("Do you want to remove ALL files from cache?"))) {
 			return 0;
 		}
 		printf(_("removing all files from cache...\n"));
@@ -345,9 +345,9 @@ static void print_installed(alpm_db_t *d
 	if(lpkg) {
 		const char *lpkgver = alpm_pkg_get_version(lpkg);
 		if(strcmp(lpkgver,pkgver) == 0) {
-			printf(" [%s]", _("installed"));
+			color_printf(COLOR_CYAN_ALL, " [%s]", _("installed"));
 		} else {
-			printf(" [%s: %s]", _("installed"), lpkgver);
+			color_printf(COLOR_CYAN_ALL, " [%s: %s]", _("installed"), lpkgver);
 		}
 	}
 }
@@ -380,8 +380,9 @@ static int sync_search(alpm_list_t *sync
 			alpm_pkg_t *pkg = alpm_list_getdata(j);
 
 			if(!config->quiet) {
-				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-							 alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s/", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 			} else {
 				printf("%s", alpm_pkg_get_name(pkg));
 			}
@@ -389,16 +390,11 @@ static int sync_search(alpm_list_t *sync
 			if(!config->quiet) {
 				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
 					alpm_list_t *k;
-					printf(" (");
+					color_printf(COLOR_BLUE_ALL, " (");
 					for(k = grp; k; k = alpm_list_next(k)) {
 						const char *group = alpm_list_getdata(k);
-						printf("%s", group);
-						if(alpm_list_next(k)) {
-							/* only print a spacer if there are more groups */
-							printf(" ");
-						}
+						color_printf(COLOR_BLUE_ALL, "%s%s", group, (alpm_list_next(k) ? " " : ")"));
 					}
-					printf(")");
 				}
 
 				print_installed(db_local, pkg);
@@ -433,8 +429,8 @@ static int sync_group(int level, alpm_li
 					/* get names of packages in group */
 					for(k = grp->packages; k; k = alpm_list_next(k)) {
 						if(!config->quiet) {
-							printf("%s %s\n", grpname,
-									alpm_pkg_get_name(alpm_list_getdata(k)));
+							color_printf(COLOR_BLUE_ALL, "%s ", grpname);
+							color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						} else {
 							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 						}
@@ -451,8 +447,8 @@ static int sync_group(int level, alpm_li
 
 				if(level > 1) {
 					for(k = grp->packages; k; k = alpm_list_next(k)) {
-						printf("%s %s\n", grp->name,
-								alpm_pkg_get_name(alpm_list_getdata(k)));
+						color_printf(COLOR_BLUE_ALL, "%s ", grp->name);
+						color_printf(COLOR_WHITE_ALL, "%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
 					}
 				} else {
 					/* print grp names only, no package names */
@@ -570,8 +566,9 @@ static int sync_list(alpm_list_t *syncs,
 			alpm_pkg_t *pkg = alpm_list_getdata(j);
 
 			if(!config->quiet) {
-				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
-						alpm_pkg_get_version(pkg));
+				color_printf(COLOR_MAGENTA_ALL, "%s ", alpm_db_get_name(db));
+				color_printf(COLOR_WHITE_ALL, "%s ", alpm_pkg_get_name(pkg));
+				color_printf(COLOR_GREEN_ALL, "%s", alpm_pkg_get_version(pkg));
 				print_installed(db_local, pkg);
 				printf("\n");
 			} else {
@@ -654,7 +651,7 @@ static int process_group(alpm_list_t *db
 
 
 	if(config->print == 0) {
-		printf(_(":: There are %d members in group %s:\n"), count,
+		color_printf(COLOR_DOUBLECOLON, _(":: There are %d members in group %s:\n"), count,
 				group);
 		select_display(pkgs);
 		char *array = malloc(count);
@@ -771,7 +768,7 @@ static int sync_trans(alpm_list_t *targe
 	}
 
 	if(config->op_s_upgrade) {
-		printf(_(":: Starting full system upgrade...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Starting full system upgrade...\n"));
 		alpm_logaction(config->handle, "starting full system upgrade\n");
 		if(alpm_sync_sysupgrade(config->handle, config->op_s_upgrade >= 2) == -1) {
 			pm_printf(ALPM_LOG_ERROR, "%s\n", alpm_strerror(alpm_errno(config->handle)));
@@ -797,14 +794,14 @@ int sync_prepare_execute(void)
 			case ALPM_ERR_PKG_INVALID_ARCH:
 				for(i = data; i; i = alpm_list_next(i)) {
 					char *pkg = alpm_list_getdata(i);
-					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+					color_printf(COLOR_DOUBLECOLON, _(":: package %s does not have a valid architecture\n"), pkg);
 				}
 				break;
 			case ALPM_ERR_UNSATISFIED_DEPS:
 				for(i = data; i; i = alpm_list_next(i)) {
 					alpm_depmissing_t *miss = alpm_list_getdata(i);
 					char *depstring = alpm_dep_compute_string(miss->depend);
-					printf(_(":: %s: requires %s\n"), miss->target, depstring);
+					color_printf(COLOR_DOUBLECOLON, _(":: %s: requires %s\n"), miss->target, depstring);
 					free(depstring);
 				}
 				break;
@@ -813,11 +810,11 @@ int sync_prepare_execute(void)
 					alpm_conflict_t *conflict = alpm_list_getdata(i);
 					/* only print reason if it contains new information */
 					if(conflict->reason->mod == ALPM_DEP_MOD_ANY) {
-						printf(_(":: %s and %s are in conflict\n"),
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict\n"),
 								conflict->package1, conflict->package2);
 					} else {
 						char *reason = alpm_dep_compute_string(conflict->reason);
-						printf(_(":: %s and %s are in conflict (%s)\n"),
+						color_printf(COLOR_DOUBLECOLON, _(":: %s and %s are in conflict (%s)\n"),
 								conflict->package1, conflict->package2, reason);
 						free(reason);
 					}
@@ -850,9 +847,9 @@ int sync_prepare_execute(void)
 
 	int confirm;
 	if(config->op_s_downloadonly) {
-		confirm = yesno(_("Proceed with download?"));
+		confirm = yesno(NULL, _("Proceed with download?"));
 	} else {
-		confirm = yesno(_("Proceed with installation?"));
+		confirm = yesno(NULL, _("Proceed with installation?"));
 	}
 	if(!confirm) {
 		goto cleanup;
@@ -872,7 +869,7 @@ int sync_prepare_execute(void)
 									conflict->file, conflict->target, conflict->ctarget);
 							break;
 						case ALPM_FILECONFLICT_FILESYSTEM:
-							printf(_("%s: %s exists in filesystem\n"),
+							color_printf(COLOR_WHITE_COLON, _("%s: %s exists in filesystem\n"),
 									conflict->target, conflict->file);
 							break;
 					}
@@ -891,7 +888,7 @@ int sync_prepare_execute(void)
 				break;
 		}
 		/* TODO: stderr? */
-		printf(_("Errors occurred, no packages were upgraded.\n"));
+		color_printf(COLOR_RED_ALL, _("Errors occurred, no packages were upgraded.\n"));
 		retval = 1;
 		goto cleanup;
 	}
@@ -939,7 +936,7 @@ int pacman_sync(alpm_list_t *targets)
 
 	if(config->op_s_sync) {
 		/* grab a fresh package list */
-		printf(_(":: Synchronizing package databases...\n"));
+		color_printf(COLOR_DOUBLECOLON, _(":: Synchronizing package databases...\n"));
 		alpm_logaction(config->handle, "synchronizing package lists\n");
 		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
 			return 1;
@@ -992,9 +989,9 @@ int pacman_sync(alpm_list_t *targets)
 			alpm_list_t *tmp = NULL;
 			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
 				alpm_list_free(tmp);
-				printf(_(":: The following packages should be upgraded first :\n"));
-				list_display("   ", packages);
-				if(yesno(_(":: Do you want to cancel the current operation\n"
+				color_printf(COLOR_DOUBLECOLON, _(":: The following packages should be upgraded first :\n"));
+				list_display(NULL, "   ", packages);
+				if(yesno(COLOR_DOUBLECOLON2, _(":: Do you want to cancel the current operation\n"
 								":: and upgrade these packages now?"))) {
 					FREELIST(targs);
 					targs = packages;
diff -Npaur a/src/pacman/sync.c.orig b/src/pacman/sync.c.orig
--- a/src/pacman/sync.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/pacman/sync.c.orig	2012-04-11 18:50:50.777479964 +0300
@@ -0,0 +1,1020 @@
+/*
+ *  sync.c
+ *
+ *  Copyright (c) 2006-2012 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <limits.h>
+#include <unistd.h>
+#include <errno.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <fnmatch.h>
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "pacman.h"
+#include "util.h"
+#include "package.h"
+#include "conf.h"
+
+static int unlink_verbose(const char *pathname, int ignore_missing)
+{
+	int ret = unlink(pathname);
+	if(ret) {
+		if(ignore_missing && errno == ENOENT) {
+			ret = 0;
+		} else {
+			pm_printf(ALPM_LOG_ERROR, _("could not remove %s: %s\n"),
+					pathname, strerror(errno));
+		}
+	}
+	return ret;
+}
+
+/* if keep_used != 0, then the db files which match an used syncdb
+ * will be kept  */
+static int sync_cleandb(const char *dbpath, int keep_used)
+{
+	DIR *dir;
+	struct dirent *ent;
+	alpm_list_t *syncdbs;
+	int ret = 0;
+
+	dir = opendir(dbpath);
+	if(dir == NULL) {
+		pm_printf(ALPM_LOG_ERROR, _("could not access database directory\n"));
+		return 1;
+	}
+
+	syncdbs = alpm_option_get_syncdbs(config->handle);
+
+	rewinddir(dir);
+	/* step through the directory one file at a time */
+	while((ent = readdir(dir)) != NULL) {
+		char path[PATH_MAX];
+		struct stat buf;
+		int found = 0;
+		const char *dname = ent->d_name;
+		char *dbname;
+		size_t len;
+
+		if(strcmp(dname, ".") == 0 || strcmp(dname, "..") == 0) {
+			continue;
+		}
+		/* skip the local and sync directories */
+		if(strcmp(dname, "sync") == 0 || strcmp(dname, "local") == 0) {
+			continue;
+		}
+		/* skip the db.lck file */
+		if(strcmp(dname, "db.lck") == 0) {
+			continue;
+		}
+
+		/* build the full path */
+		snprintf(path, PATH_MAX, "%s%s", dbpath, dname);
+
+		/* remove all non-skipped directories and non-database files */
+		stat(path, &buf);
+		if(S_ISDIR(buf.st_mode)) {
+			if(rmrf(path)) {
+				pm_printf(ALPM_LOG_ERROR, _("could not remove %s: %s\n"),
+						path, strerror(errno));
+			}
+			continue;
+		}
+
+		len = strlen(dname);
+		if(len > 3 && strcmp(dname + len - 3, ".db") == 0) {
+			dbname = strndup(dname, len - 3);
+		} else if(len > 7 && strcmp(dname + len - 7, ".db.sig") == 0) {
+			dbname = strndup(dname, len - 7);
+		} else {
+			ret += unlink_verbose(path, 0);
+			continue;
+		}
+
+		if(keep_used) {
+			alpm_list_t *i;
+			for(i = syncdbs; i && !found; i = alpm_list_next(i)) {
+				alpm_db_t *db = alpm_list_getdata(i);
+				found = !strcmp(dbname, alpm_db_get_name(db));
+			}
+		}
+
+		/* We have a database that doesn't match any syncdb. */
+		if(!found) {
+			/* ENOENT check is because the signature and database could come in any
+			 * order in our readdir() call, so either file may already be gone. */
+			snprintf(path, PATH_MAX, "%s%s.db", dbpath, dbname);
+			ret += unlink_verbose(path, 1);
+			/* unlink a signature file if present too */
+			snprintf(path, PATH_MAX, "%s%s.db.sig", dbpath, dbname);
+			ret += unlink_verbose(path, 1);
+		}
+		free(dbname);
+	}
+	closedir(dir);
+	return ret;
+}
+
+static int sync_cleandb_all(void)
+{
+	const char *dbpath;
+	char *newdbpath;
+	int ret = 0;
+
+	dbpath = alpm_option_get_dbpath(config->handle);
+	printf(_("Database directory: %s\n"), dbpath);
+	if(!yesno(_("Do you want to remove unused repositories?"))) {
+		return 0;
+	}
+	printf(_("removing unused sync repositories...\n"));
+	/* The sync dbs were previously put in dbpath/ but are now in dbpath/sync/.
+	 * We will clean everything in dbpath/ except local/, sync/ and db.lck, and
+	 * only the unused sync dbs in dbpath/sync/ */
+	ret += sync_cleandb(dbpath, 0);
+
+	if(asprintf(&newdbpath, "%s%s", dbpath, "sync/") < 0) {
+		ret += 1;
+		return ret;
+	}
+	ret += sync_cleandb(newdbpath, 1);
+	free(newdbpath);
+
+	return ret;
+}
+
+static int sync_cleancache(int level)
+{
+	alpm_list_t *i;
+	alpm_list_t *sync_dbs = alpm_option_get_syncdbs(config->handle);
+	alpm_db_t *db_local = alpm_option_get_localdb(config->handle);
+	alpm_list_t *cachedirs = alpm_option_get_cachedirs(config->handle);
+	int ret = 0;
+
+	for(i = cachedirs; i; i = alpm_list_next(i)) {
+		printf(_("Cache directory: %s\n"), (char *)alpm_list_getdata(i));
+	}
+
+	if(!config->cleanmethod) {
+		/* default to KeepInstalled if user did not specify */
+		config->cleanmethod = PM_CLEAN_KEEPINST;
+	}
+
+	if(level == 1) {
+		printf(_("Packages to keep:\n"));
+		if(config->cleanmethod & PM_CLEAN_KEEPINST) {
+			printf(_("  All locally installed packages\n"));
+		}
+		if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
+			printf(_("  All current sync database packages\n"));
+		}
+		if(!yesno(_("Do you want to remove all other packages from cache?"))) {
+			return 0;
+		}
+		printf(_("removing old packages from cache...\n"));
+	} else {
+		if(!noyes(_("Do you want to remove ALL files from cache?"))) {
+			return 0;
+		}
+		printf(_("removing all files from cache...\n"));
+	}
+
+	for(i = cachedirs; i; i = alpm_list_next(i)) {
+		const char *cachedir = alpm_list_getdata(i);
+		DIR *dir = opendir(cachedir);
+		struct dirent *ent;
+
+		if(dir == NULL) {
+			pm_printf(ALPM_LOG_ERROR,
+					_("could not access cache directory %s\n"), cachedir);
+			ret++;
+			continue;
+		}
+
+		rewinddir(dir);
+		/* step through the directory one file at a time */
+		while((ent = readdir(dir)) != NULL) {
+			char path[PATH_MAX];
+			int delete = 1;
+			alpm_pkg_t *localpkg = NULL, *pkg = NULL;
+			const char *local_name, *local_version;
+
+			if(strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) {
+				continue;
+			}
+
+			/* skip signature files - they are removed with their package file */
+			if(fnmatch("*.sig", ent->d_name, 0) == 0) {
+				continue;
+			}
+
+			/* skip package database within the cache directory */
+			if(fnmatch("*.db*", ent->d_name, 0) == 0) {
+				continue;
+			}
+
+			/* skip source packages within the cache directory */
+			if(fnmatch("*.src.tar*", ent->d_name, 0) == 0) {
+				continue;
+			}
+
+			/* build the full filepath */
+			snprintf(path, PATH_MAX, "%s%s", cachedir, ent->d_name);
+
+			/* short circuit for removing all files from cache */
+			if(level > 1) {
+				ret += unlink_verbose(path, 0);
+				continue;
+			}
+
+			/* attempt to load the file as a package. if we cannot load the file,
+			 * simply skip it and move on. we don't need a full load of the package,
+			 * just the metadata. */
+			if(alpm_pkg_load(config->handle, path, 0, 0, &localpkg) != 0) {
+				pm_printf(ALPM_LOG_DEBUG, "skipping %s, could not load as package\n",
+						path);
+				continue;
+			}
+			local_name = alpm_pkg_get_name(localpkg);
+			local_version = alpm_pkg_get_version(localpkg);
+
+			if(config->cleanmethod & PM_CLEAN_KEEPINST) {
+				/* check if this package is in the local DB */
+				pkg = alpm_db_get_pkg(db_local, local_name);
+				if(pkg != NULL && alpm_pkg_vercmp(local_version,
+							alpm_pkg_get_version(pkg)) == 0) {
+					/* package was found in local DB and version matches, keep it */
+					pm_printf(ALPM_LOG_DEBUG, "package %s-%s found in local db\n",
+							local_name, local_version);
+					delete = 0;
+				}
+			}
+			if(config->cleanmethod & PM_CLEAN_KEEPCUR) {
+				alpm_list_t *j;
+				/* check if this package is in a sync DB */
+				for(j = sync_dbs; j && delete; j = alpm_list_next(j)) {
+					alpm_db_t *db = alpm_list_getdata(j);
+					pkg = alpm_db_get_pkg(db, local_name);
+					if(pkg != NULL && alpm_pkg_vercmp(local_version,
+								alpm_pkg_get_version(pkg)) == 0) {
+						/* package was found in a sync DB and version matches, keep it */
+						pm_printf(ALPM_LOG_DEBUG, "package %s-%s found in sync db\n",
+								local_name, local_version);
+						delete = 0;
+					}
+				}
+			}
+			/* free the local file package */
+			alpm_pkg_free(localpkg);
+
+			if(delete) {
+				size_t pathlen = strlen(path);
+				ret += unlink_verbose(path, 0);
+				/* unlink a signature file if present too */
+				if(PATH_MAX - 5 >= pathlen) {
+					strcpy(path + pathlen, ".sig");
+					ret += unlink_verbose(path, 1);
+				}
+			}
+		}
+		closedir(dir);
+	}
+
+	return ret;
+}
+
+static int sync_synctree(int level, alpm_list_t *syncs)
+{
+	alpm_list_t *i;
+	int success = 0, ret;
+
+	for(i = syncs; i; i = alpm_list_next(i)) {
+		alpm_db_t *db = alpm_list_getdata(i);
+
+		ret = alpm_db_update((level < 2 ? 0 : 1), db);
+		if(ret < 0) {
+			pm_printf(ALPM_LOG_ERROR, _("failed to update %s (%s)\n"),
+					alpm_db_get_name(db), alpm_strerror(alpm_errno(config->handle)));
+		} else if(ret == 1) {
+			printf(_(" %s is up to date\n"), alpm_db_get_name(db));
+			success++;
+		} else {
+			success++;
+		}
+	}
+
+	/* We should always succeed if at least one DB was upgraded - we may possibly
+	 * fail later with unresolved deps, but that should be rare, and would be
+	 * expected
+	 */
+	if(!success) {
+		pm_printf(ALPM_LOG_ERROR, _("failed to synchronize any databases\n"));
+		trans_init_error();
+	}
+	return (success > 0);
+}
+
+static void print_installed(alpm_db_t *db_local, alpm_pkg_t *pkg)
+{
+	const char *pkgname = alpm_pkg_get_name(pkg);
+	const char *pkgver = alpm_pkg_get_version(pkg);
+	alpm_pkg_t *lpkg = alpm_db_get_pkg(db_local, pkgname);
+	if(lpkg) {
+		const char *lpkgver = alpm_pkg_get_version(lpkg);
+		if(strcmp(lpkgver,pkgver) == 0) {
+			printf(" [%s]", _("installed"));
+		} else {
+			printf(" [%s: %s]", _("installed"), lpkgver);
+		}
+	}
+}
+
+/* search the sync dbs for a matching package */
+static int sync_search(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *ret;
+	int freelist;
+	int found = 0;
+	alpm_db_t *db_local = alpm_option_get_localdb(config->handle);
+
+	for(i = syncs; i; i = alpm_list_next(i)) {
+		alpm_db_t *db = alpm_list_getdata(i);
+		/* if we have a targets list, search for packages matching it */
+		if(targets) {
+			ret = alpm_db_search(db, targets);
+			freelist = 1;
+		} else {
+			ret = alpm_db_get_pkgcache(db);
+			freelist = 0;
+		}
+		if(ret == NULL) {
+			continue;
+		} else {
+			found = 1;
+		}
+		for(j = ret; j; j = alpm_list_next(j)) {
+			alpm_list_t *grp;
+			alpm_pkg_t *pkg = alpm_list_getdata(j);
+
+			if(!config->quiet) {
+				printf("%s/%s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
+							 alpm_pkg_get_version(pkg));
+			} else {
+				printf("%s", alpm_pkg_get_name(pkg));
+			}
+
+			if(!config->quiet) {
+				if((grp = alpm_pkg_get_groups(pkg)) != NULL) {
+					alpm_list_t *k;
+					printf(" (");
+					for(k = grp; k; k = alpm_list_next(k)) {
+						const char *group = alpm_list_getdata(k);
+						printf("%s", group);
+						if(alpm_list_next(k)) {
+							/* only print a spacer if there are more groups */
+							printf(" ");
+						}
+					}
+					printf(")");
+				}
+
+				print_installed(db_local, pkg);
+
+				/* we need a newline and initial indent first */
+				printf("\n    ");
+				indentprint(alpm_pkg_get_desc(pkg), 4);
+			}
+			printf("\n");
+		}
+		/* we only want to free if the list was a search list */
+		if(freelist) {
+			alpm_list_free(ret);
+		}
+	}
+
+	return !found;
+}
+
+static int sync_group(int level, alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *k;
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			const char *grpname = alpm_list_getdata(i);
+			for(j = syncs; j; j = alpm_list_next(j)) {
+				alpm_db_t *db = alpm_list_getdata(j);
+				alpm_group_t *grp = alpm_db_readgroup(db, grpname);
+
+				if(grp) {
+					/* get names of packages in group */
+					for(k = grp->packages; k; k = alpm_list_next(k)) {
+						if(!config->quiet) {
+							printf("%s %s\n", grpname,
+									alpm_pkg_get_name(alpm_list_getdata(k)));
+						} else {
+							printf("%s\n", alpm_pkg_get_name(alpm_list_getdata(k)));
+						}
+					}
+				}
+			}
+		}
+	} else {
+		for(i = syncs; i; i = alpm_list_next(i)) {
+			alpm_db_t *db = alpm_list_getdata(i);
+
+			for(j = alpm_db_get_groupcache(db); j; j = alpm_list_next(j)) {
+				alpm_group_t *grp = alpm_list_getdata(j);
+
+				if(level > 1) {
+					for(k = grp->packages; k; k = alpm_list_next(k)) {
+						printf("%s %s\n", grp->name,
+								alpm_pkg_get_name(alpm_list_getdata(k)));
+					}
+				} else {
+					/* print grp names only, no package names */
+					printf("%s\n", grp->name);
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int sync_info(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *k;
+	int ret = 0;
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			const char *target = alpm_list_getdata(i);
+			char *name = strdup(target);
+			char *repo, *pkgstr;
+			int foundpkg = 0, founddb = 0;
+
+			pkgstr = strchr(name, '/');
+			if(pkgstr) {
+				repo = name;
+				*pkgstr = '\0';
+				++pkgstr;
+			} else {
+				repo = NULL;
+				pkgstr = name;
+			}
+
+			for(j = syncs; j; j = alpm_list_next(j)) {
+				alpm_db_t *db = alpm_list_getdata(j);
+				if(repo && strcmp(repo, alpm_db_get_name(db)) != 0) {
+					continue;
+				}
+				founddb = 1;
+
+				for(k = alpm_db_get_pkgcache(db); k; k = alpm_list_next(k)) {
+					alpm_pkg_t *pkg = alpm_list_getdata(k);
+
+					if(strcmp(alpm_pkg_get_name(pkg), pkgstr) == 0) {
+						dump_pkg_full(pkg, config->op_s_info > 1);
+						foundpkg = 1;
+						break;
+					}
+				}
+			}
+
+			if(!founddb) {
+				pm_printf(ALPM_LOG_ERROR,
+						_("repository '%s' does not exist\n"), repo);
+				ret++;
+			}
+			if(!foundpkg) {
+				pm_printf(ALPM_LOG_ERROR,
+						_("package '%s' was not found\n"), target);
+				ret++;
+			}
+			free(name);
+		}
+	} else {
+		for(i = syncs; i; i = alpm_list_next(i)) {
+			alpm_db_t *db = alpm_list_getdata(i);
+
+			for(j = alpm_db_get_pkgcache(db); j; j = alpm_list_next(j)) {
+				alpm_pkg_t *pkg = alpm_list_getdata(j);
+				dump_pkg_full(pkg, config->op_s_info > 1);
+			}
+		}
+	}
+
+	return ret;
+}
+
+static int sync_list(alpm_list_t *syncs, alpm_list_t *targets)
+{
+	alpm_list_t *i, *j, *ls = NULL;
+	alpm_db_t *db_local = alpm_option_get_localdb(config->handle);
+
+	if(targets) {
+		for(i = targets; i; i = alpm_list_next(i)) {
+			const char *repo = alpm_list_getdata(i);
+			alpm_db_t *db = NULL;
+
+			for(j = syncs; j; j = alpm_list_next(j)) {
+				alpm_db_t *d = alpm_list_getdata(j);
+
+				if(strcmp(repo, alpm_db_get_name(d)) == 0) {
+					db = d;
+					break;
+				}
+			}
+
+			if(db == NULL) {
+				pm_printf(ALPM_LOG_ERROR,
+					_("repository \"%s\" was not found.\n"),repo);
+				alpm_list_free(ls);
+				return 1;
+			}
+
+			ls = alpm_list_add(ls, db);
+		}
+	} else {
+		ls = syncs;
+	}
+
+	for(i = ls; i; i = alpm_list_next(i)) {
+		alpm_db_t *db = alpm_list_getdata(i);
+
+		for(j = alpm_db_get_pkgcache(db); j; j = alpm_list_next(j)) {
+			alpm_pkg_t *pkg = alpm_list_getdata(j);
+
+			if(!config->quiet) {
+				printf("%s %s %s", alpm_db_get_name(db), alpm_pkg_get_name(pkg),
+						alpm_pkg_get_version(pkg));
+				print_installed(db_local, pkg);
+				printf("\n");
+			} else {
+				printf("%s\n", alpm_pkg_get_name(pkg));
+			}
+		}
+	}
+
+	if(targets) {
+		alpm_list_free(ls);
+	}
+
+	return 0;
+}
+
+static alpm_list_t *syncfirst(void) {
+	alpm_list_t *i, *res = NULL;
+	alpm_db_t *db_local = alpm_option_get_localdb(config->handle);
+	alpm_list_t *syncdbs = alpm_option_get_syncdbs(config->handle);
+
+	for(i = config->syncfirst; i; i = alpm_list_next(i)) {
+		char *pkgname = alpm_list_getdata(i);
+		alpm_pkg_t *pkg = alpm_db_get_pkg(db_local, pkgname);
+		if(pkg == NULL) {
+			continue;
+		}
+
+		if(alpm_sync_newversion(pkg, syncdbs)) {
+			res = alpm_list_add(res, strdup(pkgname));
+		}
+	}
+
+	return res;
+}
+
+static alpm_db_t *get_db(const char *dbname)
+{
+	alpm_list_t *i;
+	for(i = alpm_option_get_syncdbs(config->handle); i; i = i->next) {
+		alpm_db_t *db = i->data;
+		if(strcmp(alpm_db_get_name(db), dbname) == 0) {
+			return db;
+		}
+	}
+	return NULL;
+}
+
+static int process_pkg(alpm_pkg_t *pkg)
+{
+	int ret = alpm_add_pkg(config->handle, pkg);
+
+	if(ret == -1) {
+		enum _alpm_errno_t err = alpm_errno(config->handle);
+		if(err == ALPM_ERR_TRANS_DUP_TARGET
+				|| err == ALPM_ERR_PKG_IGNORED) {
+			/* just skip duplicate or ignored targets */
+			pm_printf(ALPM_LOG_WARNING, _("skipping target: %s\n"), alpm_pkg_get_name(pkg));
+			return 0;
+		} else {
+			pm_printf(ALPM_LOG_ERROR, "'%s': %s\n", alpm_pkg_get_name(pkg),
+					alpm_strerror(err));
+			return 1;
+		}
+	}
+	config->explicit_adds = alpm_list_add(config->explicit_adds, pkg);
+	return 0;
+}
+
+static int process_group(alpm_list_t *dbs, const char *group)
+{
+	int ret = 0;
+	alpm_list_t *i;
+	alpm_list_t *pkgs = alpm_find_group_pkgs(dbs, group);
+	int count = alpm_list_count(pkgs);
+
+	if(!count) {
+		pm_printf(ALPM_LOG_ERROR, _("target not found: %s\n"), group);
+		return 1;
+	}
+
+
+	if(config->print == 0) {
+		printf(_(":: There are %d members in group %s:\n"), count,
+				group);
+		select_display(pkgs);
+		char *array = malloc(count);
+		if(!array) {
+			ret = 1;
+			goto cleanup;
+		}
+		if(multiselect_question(array, count)) {
+			ret = 1;
+			free(array);
+			goto cleanup;
+		}
+		int n = 0;
+		for(i = pkgs; i; i = alpm_list_next(i)) {
+			if(array[n++] == 0)
+				continue;
+			alpm_pkg_t *pkg = alpm_list_getdata(i);
+
+			if(process_pkg(pkg) == 1) {
+				ret = 1;
+				free(array);
+				goto cleanup;
+			}
+		}
+		free(array);
+	} else {
+		for(i = pkgs; i; i = alpm_list_next(i)) {
+			alpm_pkg_t *pkg = alpm_list_getdata(i);
+
+			if(process_pkg(pkg) == 1) {
+				ret = 1;
+				goto cleanup;
+			}
+		}
+	}
+cleanup:
+	alpm_list_free(pkgs);
+	return ret;
+}
+
+static int process_targname(alpm_list_t *dblist, const char *targname)
+{
+	alpm_pkg_t *pkg = alpm_find_dbs_satisfier(config->handle, dblist, targname);
+
+	/* #FS#23342 - skip ignored packages when user says no */
+	if(alpm_errno(config->handle) == ALPM_ERR_PKG_IGNORED) {
+			pm_printf(ALPM_LOG_WARNING, _("skipping target: %s\n"), targname);
+			return 0;
+	}
+
+	if(pkg) {
+		return process_pkg(pkg);
+	}
+	/* fallback on group */
+	return process_group(dblist, targname);
+}
+
+static int process_target(const char *target)
+{
+	/* process targets */
+	char *targstring = strdup(target);
+	char *targname = strchr(targstring, '/');
+	char *dbname = NULL;
+	int ret = 0;
+	alpm_list_t *dblist = NULL;
+
+	if(targname && targname != targstring) {
+		alpm_db_t *db = NULL;
+
+		*targname = '\0';
+		targname++;
+		dbname = targstring;
+		db = get_db(dbname);
+		if(!db) {
+			pm_printf(ALPM_LOG_ERROR, _("database not found: %s\n"),
+					dbname);
+			ret = 1;
+			goto cleanup;
+		}
+		dblist = alpm_list_add(dblist, db);
+		ret = process_targname(dblist, targname);
+		alpm_list_free(dblist);
+	} else {
+		targname = targstring;
+		dblist = alpm_option_get_syncdbs(config->handle);
+		ret = process_targname(dblist, targname);
+	}
+cleanup:
+	free(targstring);
+	if(ret && access(target, R_OK) == 0) {
+		pm_printf(ALPM_LOG_WARNING,
+				_("'%s' is a file, did you mean %s instead of %s?\n"),
+				target, "-U/--upgrade", "-S/--sync");
+	}
+	return ret;
+}
+
+static int sync_trans(alpm_list_t *targets)
+{
+	alpm_list_t *i;
+
+	/* Step 1: create a new transaction... */
+	if(trans_init(config->flags, 1) == -1) {
+		return 1;
+	}
+
+	/* process targets */
+	for(i = targets; i; i = alpm_list_next(i)) {
+		char *targ = alpm_list_getdata(i);
+		if(process_target(targ) == 1) {
+			trans_release();
+			return 1;
+		}
+	}
+
+	if(config->op_s_upgrade) {
+		printf(_(":: Starting full system upgrade...\n"));
+		alpm_logaction(config->handle, "starting full system upgrade\n");
+		if(alpm_sync_sysupgrade(config->handle, config->op_s_upgrade >= 2) == -1) {
+			pm_printf(ALPM_LOG_ERROR, "%s\n", alpm_strerror(alpm_errno(config->handle)));
+			trans_release();
+			return 1;
+		}
+	}
+
+	return sync_prepare_execute();
+}
+
+int sync_prepare_execute(void)
+{
+	alpm_list_t *i, *packages, *data = NULL;
+	int retval = 0;
+
+	/* Step 2: "compute" the transaction based on targets and flags */
+	if(alpm_trans_prepare(config->handle, &data) == -1) {
+		enum _alpm_errno_t err = alpm_errno(config->handle);
+		pm_printf(ALPM_LOG_ERROR, _("failed to prepare transaction (%s)\n"),
+		        alpm_strerror(err));
+		switch(err) {
+			case ALPM_ERR_PKG_INVALID_ARCH:
+				for(i = data; i; i = alpm_list_next(i)) {
+					char *pkg = alpm_list_getdata(i);
+					printf(_(":: package %s does not have a valid architecture\n"), pkg);
+				}
+				break;
+			case ALPM_ERR_UNSATISFIED_DEPS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					alpm_depmissing_t *miss = alpm_list_getdata(i);
+					char *depstring = alpm_dep_compute_string(miss->depend);
+					printf(_(":: %s: requires %s\n"), miss->target, depstring);
+					free(depstring);
+				}
+				break;
+			case ALPM_ERR_CONFLICTING_DEPS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					alpm_conflict_t *conflict = alpm_list_getdata(i);
+					/* only print reason if it contains new information */
+					if(conflict->reason->mod == ALPM_DEP_MOD_ANY) {
+						printf(_(":: %s and %s are in conflict\n"),
+								conflict->package1, conflict->package2);
+					} else {
+						char *reason = alpm_dep_compute_string(conflict->reason);
+						printf(_(":: %s and %s are in conflict (%s)\n"),
+								conflict->package1, conflict->package2, reason);
+						free(reason);
+					}
+				}
+				break;
+			default:
+				break;
+		}
+		retval = 1;
+		goto cleanup;
+	}
+
+	packages = alpm_trans_get_add(config->handle);
+	if(packages == NULL) {
+		/* nothing to do: just exit without complaining */
+		if(!config->print) {
+			printf(_(" there is nothing to do\n"));
+		}
+		goto cleanup;
+	}
+
+	/* Step 3: actually perform the operation */
+	if(config->print) {
+		print_packages(packages);
+		goto cleanup;
+	}
+
+	display_targets();
+	printf("\n");
+
+	int confirm;
+	if(config->op_s_downloadonly) {
+		confirm = yesno(_("Proceed with download?"));
+	} else {
+		confirm = yesno(_("Proceed with installation?"));
+	}
+	if(!confirm) {
+		goto cleanup;
+	}
+
+	if(alpm_trans_commit(config->handle, &data) == -1) {
+		enum _alpm_errno_t err = alpm_errno(config->handle);
+		pm_printf(ALPM_LOG_ERROR, _("failed to commit transaction (%s)\n"),
+		        alpm_strerror(err));
+		switch(err) {
+			case ALPM_ERR_FILE_CONFLICTS:
+				for(i = data; i; i = alpm_list_next(i)) {
+					alpm_fileconflict_t *conflict = alpm_list_getdata(i);
+					switch(conflict->type) {
+						case ALPM_FILECONFLICT_TARGET:
+							printf(_("%s exists in both '%s' and '%s'\n"),
+									conflict->file, conflict->target, conflict->ctarget);
+							break;
+						case ALPM_FILECONFLICT_FILESYSTEM:
+							printf(_("%s: %s exists in filesystem\n"),
+									conflict->target, conflict->file);
+							break;
+					}
+				}
+				break;
+			case ALPM_ERR_PKG_INVALID:
+			case ALPM_ERR_PKG_INVALID_CHECKSUM:
+			case ALPM_ERR_PKG_INVALID_SIG:
+			case ALPM_ERR_DLT_INVALID:
+				for(i = data; i; i = alpm_list_next(i)) {
+					const char *filename = alpm_list_getdata(i);
+					printf(_("%s is invalid or corrupted\n"), filename);
+				}
+				break;
+			default:
+				break;
+		}
+		/* TODO: stderr? */
+		printf(_("Errors occurred, no packages were upgraded.\n"));
+		retval = 1;
+		goto cleanup;
+	}
+
+	/* Step 4: release transaction resources */
+cleanup:
+	if(data) {
+		FREELIST(data);
+	}
+	if(trans_release() == -1) {
+		retval = 1;
+	}
+
+	return retval;
+}
+
+int pacman_sync(alpm_list_t *targets)
+{
+	alpm_list_t *sync_dbs = NULL;
+
+	/* clean the cache */
+	if(config->op_s_clean) {
+		int ret = 0;
+
+		if(trans_init(0, 0) == -1) {
+			return 1;
+		}
+
+		ret += sync_cleancache(config->op_s_clean);
+		printf("\n");
+		ret += sync_cleandb_all();
+
+		if(trans_release() == -1) {
+			ret++;
+		}
+
+		return ret;
+	}
+
+	if(check_syncdbs(1, 0)) {
+		return 1;
+	}
+
+	sync_dbs = alpm_option_get_syncdbs(config->handle);
+
+	if(config->op_s_sync) {
+		/* grab a fresh package list */
+		printf(_(":: Synchronizing package databases...\n"));
+		alpm_logaction(config->handle, "synchronizing package lists\n");
+		if(!sync_synctree(config->op_s_sync, sync_dbs)) {
+			return 1;
+		}
+	}
+
+	if(check_syncdbs(1, 1)) {
+		return 1;
+	}
+
+	/* search for a package */
+	if(config->op_s_search) {
+		return sync_search(sync_dbs, targets);
+	}
+
+	/* look for groups */
+	if(config->group) {
+		return sync_group(config->group, sync_dbs, targets);
+	}
+
+	/* get package info */
+	if(config->op_s_info) {
+		return sync_info(sync_dbs, targets);
+	}
+
+	/* get a listing of files in sync DBs */
+	if(config->op_q_list) {
+		return sync_list(sync_dbs, targets);
+	}
+
+	if(targets == NULL) {
+		if(config->op_s_upgrade) {
+			/* proceed */
+		} else if(config->op_s_sync) {
+			return 0;
+		} else {
+			/* don't proceed here unless we have an operation that doesn't require a
+			 * target list */
+			pm_printf(ALPM_LOG_ERROR, _("no targets specified (use -h for help)\n"));
+			return 1;
+		}
+	}
+
+	alpm_list_t *targs = alpm_list_strdup(targets);
+	if(!config->op_s_downloadonly && !config->print) {
+		/* check for newer versions of packages to be upgraded first */
+		alpm_list_t *packages = syncfirst();
+		if(packages) {
+			/* Do not ask user if all the -S targets are SyncFirst packages, see FS#15810 */
+			alpm_list_t *tmp = NULL;
+			if(config->op_s_upgrade || (tmp = alpm_list_diff(targets, packages, (alpm_list_fn_cmp)strcmp))) {
+				alpm_list_free(tmp);
+				printf(_(":: The following packages should be upgraded first :\n"));
+				list_display("   ", packages);
+				if(yesno(_(":: Do you want to cancel the current operation\n"
+								":: and upgrade these packages now?"))) {
+					FREELIST(targs);
+					targs = packages;
+					config->flags = 0;
+					config->op_s_upgrade = 0;
+				} else {
+					FREELIST(packages);
+				}
+				printf("\n");
+			} else {
+				pm_printf(ALPM_LOG_DEBUG, "skipping SyncFirst dialog\n");
+				FREELIST(packages);
+			}
+		}
+	}
+
+	int ret = sync_trans(targs);
+	FREELIST(targs);
+
+	return ret;
+}
+
+/* vim: set ts=2 sw=2 noet: */
diff -Npaur a/src/pacman/util.c b/src/pacman/util.c
--- a/src/pacman/util.c	2012-02-20 07:18:31.000000000 +0200
+++ b/src/pacman/util.c	2012-04-11 18:51:00.948480616 +0300
@@ -48,6 +48,20 @@
 #include "conf.h"
 #include "callback.h"
 
+#define COLOR_LEN 8
+
+typedef struct __colortab_t {
+	char red[COLOR_LEN + 1];
+	char green[COLOR_LEN + 1];
+	char yellow[COLOR_LEN + 1];
+	char blue[COLOR_LEN + 1];
+	char magenta[COLOR_LEN + 1];
+	char cyan[COLOR_LEN + 1];
+	char white[COLOR_LEN + 1];
+	char none[COLOR_LEN + 1];
+} colortab_t;
+
+static colortab_t colortab;
 
 int trans_init(alpm_transflag_t flags, int check_valid)
 {
@@ -463,10 +477,10 @@ static size_t string_length(const char *
 	return len;
 }
 
-void string_display(const char *title, const char *string)
+void string_display(const colordata_t *colors_title, const char *title, const char *string)
 {
 	if(title) {
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 	if(string == NULL || string[0] == '\0') {
 		printf(_("None"));
@@ -599,14 +613,14 @@ int table_display(const char *title, con
 	return 0;
 }
 
-void list_display(const char *title, const alpm_list_t *list)
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	const alpm_list_t *i;
 	size_t len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -640,13 +654,13 @@ void list_display(const char *title, con
 	}
 }
 
-void list_display_linebreak(const char *title, const alpm_list_t *list)
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list)
 {
 	size_t len = 0;
 
 	if(title) {
 		len = string_length(title) + 1;
-		printf("%s ", title);
+		color_printf(colors_title, "%s ", title);
 	}
 
 	if(!list) {
@@ -867,11 +881,11 @@ static void _display_targets(alpm_list_t
 		alpm_list_t *header = create_verbose_header(show_dl_size);
 		if(table_display(str, header, rows) != 0) {
 			/* fallback to list display if table wouldn't fit */
-			list_display(str, names);
+			list_display(COLOR_YELLOW_ALL, str, names);
 		}
 		alpm_list_free(header);
 	} else {
-		list_display(str, names);
+		list_display(COLOR_YELLOW_ALL, str, names);
 	}
 	printf("\n");
 
@@ -886,21 +900,21 @@ static void _display_targets(alpm_list_t
 
 	if(dlsize > 0 || config->op_s_downloadonly) {
 		size = humanize_size(dlsize, 'M', 2, &label);
-		printf(_("Total Download Size:    %.2f %s\n"), size, label);
+		color_printf(COLOR_WHITE_COLON, _("Total Download Size:    %.2f %s\n"), size, label);
 	}
 	if(!config->op_s_downloadonly) {
 		if(isize > 0) {
 			size = humanize_size(isize, 'M', 2, &label);
-			printf(_("Total Installed Size:   %.2f %s\n"), size, label);
+			color_printf(COLOR_WHITE_COLON, _("Total Installed Size:   %.2f %s\n"), size, label);
 		}
 		if(rsize > 0 && isize == 0) {
 			size = humanize_size(rsize, 'M', 2, &label);
-			printf(_("Total Removed Size:     %.2f %s\n"), size, label);
+			color_printf(COLOR_WHITE_COLON, _("Total Removed Size:     %.2f %s\n"), size, label);
 		}
 		/* only show this net value if different from raw installed size */
 		if(isize > 0 && rsize > 0) {
 			size = humanize_size(isize - rsize, 'M', 2, &label);
-			printf(_("Net Upgrade Size:       %.2f %s\n"), size, label);
+			color_printf(COLOR_WHITE_COLON, _("Net Upgrade Size:       %.2f %s\n"), size, label);
 		}
 	}
 }
@@ -1115,7 +1129,7 @@ void display_new_optdepends(alpm_pkg_t *
 	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
 	if(optdeps) {
 		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 	alpm_list_free(optdeps);
 }
@@ -1125,7 +1139,7 @@ void display_optdepends(alpm_pkg_t *pkg)
 	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
 	if(optdeps) {
 		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
-		list_display_linebreak("   ", optdeps);
+		list_display_linebreak(NULL, "   ", optdeps);
 	}
 }
 
@@ -1133,9 +1147,9 @@ static void display_repo_list(const char
 {
 	const char *prefix= "  ";
 
-	printf(":: ");
-	printf(_("Repository %s\n"), dbname);
-	list_display(prefix, list);
+	color_printf(COLOR_BLUE_ALL, ":: ");
+	color_printf(COLOR_WHITE_ALL, _("Repository %s\n"), dbname);
+	list_display(NULL, prefix, list);
 }
 
 void select_display(const alpm_list_t *pkglist)
@@ -1354,7 +1368,7 @@ int select_question(int count)
 
 
 /* presents a prompt and gets a Y/N answer */
-static int question(short preset, char *fmt, va_list args)
+static int question(const colordata_t *colors, short preset, char *fmt, va_list args)
 {
 	char response[32];
 	FILE *stream;
@@ -1370,7 +1384,7 @@ static int question(short preset, char *
 	fflush(stdout);
 	fflush(stderr);
 
-	vfprintf(stream, fmt, args);
+	color_vfprintf(stream, colors, fmt, args);
 
 	if(preset) {
 		fprintf(stream, " %s ", _("[Y/n]"));
@@ -1407,25 +1421,25 @@ static int question(short preset, char *
 	return 0;
 }
 
-int yesno(char *fmt, ...)
+int yesno(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(1, fmt, args);
+	ret = question(colors, 1, fmt, args);
 	va_end(args);
 
 	return ret;
 }
 
-int noyes(char *fmt, ...)
+int noyes(const colordata_t *colors, char *fmt, ...)
 {
 	int ret;
 	va_list args;
 
 	va_start(args, fmt);
-	ret = question(0, fmt, args);
+	ret = question(colors, 0, fmt, args);
 	va_end(args);
 
 	return ret;
@@ -1474,22 +1488,42 @@ int pm_vasprintf(char **string, alpm_log
 	ret = vasprintf(&msg, format, args);
 
 	/* print a prefix to the message */
-	switch(level) {
-		case ALPM_LOG_ERROR:
-			pm_asprintf(string, _("error: %s"), msg);
-			break;
-		case ALPM_LOG_WARNING:
-			pm_asprintf(string, _("warning: %s"), msg);
-			break;
-		case ALPM_LOG_DEBUG:
-			pm_asprintf(string, "debug: %s", msg);
-			break;
-		case ALPM_LOG_FUNCTION:
-			pm_asprintf(string, "function: %s", msg);
-			break;
-		default:
-			pm_asprintf(string, "%s", msg);
-			break;
+	if(isatty(fileno(stdout))) {
+		switch(level) {
+			case ALPM_LOG_ERROR:
+				pm_asprintf(string, "%s%s%s%s", colortab.red, _("error: "), colortab.none, msg);
+				break;
+			case ALPM_LOG_WARNING:
+				pm_asprintf(string, "%s%s%s%s", colortab.yellow, _("warning: "), colortab.none, msg);
+				break;
+			case ALPM_LOG_DEBUG:
+				pm_asprintf(string, "debug: %s", msg);
+				break;
+			case ALPM_LOG_FUNCTION:
+				pm_asprintf(string, "function: %s", msg);
+				break;
+			default:
+				pm_asprintf(string, "%s", msg);
+				break;
+		}
+	} else {
+		switch(level) {
+			case ALPM_LOG_ERROR:
+				pm_asprintf(string, _("error: %s"), msg);
+				break;
+			case ALPM_LOG_WARNING:
+				pm_asprintf(string, _("warning: %s"), msg);
+				break;
+			case ALPM_LOG_DEBUG:
+				pm_asprintf(string, "debug: %s", msg);
+				break;
+			case ALPM_LOG_FUNCTION:
+				pm_asprintf(string, "function: %s", msg);
+				break;
+			default:
+				pm_asprintf(string, "%s", msg);
+				break;
+		}
 	}
 	free(msg);
 
@@ -1524,10 +1558,10 @@ int pm_vfprintf(FILE *stream, alpm_logle
 	/* print a prefix to the message */
 	switch(level) {
 		case ALPM_LOG_ERROR:
-			fprintf(stream, _("error: "));
+			color_fprintf(stream, COLOR_RED_ALL, _("error: "));
 			break;
 		case ALPM_LOG_WARNING:
-			fprintf(stream, _("warning: "));
+			color_fprintf(stream, COLOR_YELLOW_ALL, _("warning: "));
 			break;
 		case ALPM_LOG_DEBUG:
 			fprintf(stream, "debug: ");
@@ -1566,4 +1600,310 @@ char *strndup(const char *s, size_t n)
 }
 #endif
 
+/* pacman-color */
+
+int _set_color_sequence(const char* name, char* dest)
+{
+	int ret = 0;
+
+	if(strcmp(name, "black") == 0) {
+		strncpy(dest, "\033[0;30m", COLOR_LEN);
+	} else if(strcmp(name, "red") == 0) {
+		strncpy(dest, "\033[0;31m", COLOR_LEN);
+	} else if(strcmp(name, "green") == 0) {
+		strncpy(dest, "\033[0;32m", COLOR_LEN);
+	} else if(strcmp(name, "yellow") == 0) {
+		strncpy(dest, "\033[0;33m", COLOR_LEN);
+	} else if(strcmp(name, "blue") == 0) {
+		strncpy(dest, "\033[0;34m", COLOR_LEN);
+	} else if(strcmp(name, "magenta") == 0) {
+		strncpy(dest, "\033[0;35m", COLOR_LEN);
+	} else if(strcmp(name, "cyan") == 0) {
+		strncpy(dest, "\033[0;36m", COLOR_LEN);
+	} else if(strcmp(name, "white") == 0) {
+		strncpy(dest, "\033[0;37m", COLOR_LEN);
+	} else if(strcmp(name, "gray") == 0) {
+		strncpy(dest, "\033[1;30m", COLOR_LEN);
+	} else if(strcmp(name, "intensive red") == 0) {
+		strncpy(dest, "\033[1;31m", COLOR_LEN);
+	} else if(strcmp(name, "intensive green") == 0) {
+		strncpy(dest, "\033[1;32m", COLOR_LEN);
+	} else if(strcmp(name, "intensive yellow") == 0) {
+		strncpy(dest, "\033[1;33m", COLOR_LEN);
+	} else if(strcmp(name, "intensive blue") == 0) {
+		strncpy(dest, "\033[1;34m", COLOR_LEN);
+	} else if(strcmp(name, "intensive magenta") == 0) {
+		strncpy(dest, "\033[1;35m", COLOR_LEN);
+	} else if(strcmp(name, "intensive cyan") == 0) {
+		strncpy(dest, "\033[1;36m", COLOR_LEN);
+	} else if(strcmp(name, "intensive white") == 0) {
+		strncpy(dest, "\033[1;37m", COLOR_LEN);
+	} else if(strcmp(name, "intensive foreground") == 0) {
+		strncpy(dest, "\033[m\033[1m", COLOR_LEN);
+	} else if(strcmp(name, "none") == 0) {
+		strncpy(dest, "\033[m", COLOR_LEN);
+	} else {
+		ret = 1;
+	}
+	dest[COLOR_LEN] = '\0';
+	return(ret);
+}
+
+void _insert_color(FILE* stream, color_t color)
+{
+	switch(color) {
+		case COLOR_RED:
+			fprintf(stream, colortab.red);
+			break;
+		case COLOR_GREEN:
+			fprintf(stream, colortab.green);
+			break;
+		case COLOR_YELLOW:
+			fprintf(stream, colortab.yellow);
+			break;
+		case COLOR_BLUE:
+			fprintf(stream, colortab.blue);
+			break;
+		case COLOR_MAGENTA:
+			fprintf(stream, colortab.magenta);
+			break;
+		case COLOR_CYAN:
+			fprintf(stream, colortab.cyan);
+			break;
+		case COLOR_WHITE:
+			fprintf(stream, colortab.white);
+			break;
+		case COLOR_NONE:
+			fprintf(stream, colortab.none);
+			break;
+		default:;
+	}
+}
+
+int _parsecolorconfig(colortab_t* colortab, char* file)
+{
+	_set_color_sequence("intensive red", colortab->red);
+	_set_color_sequence("intensive green", colortab->green);
+	_set_color_sequence("intensive yellow", colortab->yellow);
+	_set_color_sequence("intensive blue", colortab->blue);
+	_set_color_sequence("intensive magenta", colortab->magenta);
+	_set_color_sequence("intensive cyan", colortab->cyan);
+	_set_color_sequence("intensive foreground", colortab->white);
+	_set_color_sequence("none", colortab->none);
+
+	FILE* fp = NULL;
+	int linenum = 0;
+	char line[PATH_MAX+1];
+	char* ptr;
+
+	fp = fopen(file, "r");
+	if(fp == NULL) {
+		pm_printf(ALPM_LOG_ERROR, _("config file %s could not be read.\n"), file);
+		return 1;
+	}
+	while(fgets(line, PATH_MAX, fp)) {
+		linenum++;
+		strtrim(line);
+
+		if(strlen(line) == 0 || line[0] == '#') {
+			continue;
+		}
+		if((ptr = strchr(line, '#'))) {
+			*ptr = '\0';
+		}
+
+		char* key = line;
+		ptr = line;
+		strsep(&ptr, "=");
+		strtrim(key);
+		strtrim(ptr);
+
+		if(key == NULL) {
+			pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: syntax error in config file- missing key.\n"),
+					file, linenum);
+			return 1;
+		}
+		if(strcmp(key, "Red") == 0) {
+			if(_set_color_sequence(ptr, colortab->red)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Green") == 0) {
+			if(_set_color_sequence(ptr, colortab->green)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Yellow") == 0) {
+			if(_set_color_sequence(ptr, colortab->yellow)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Blue") == 0) {
+			if(_set_color_sequence(ptr, colortab->blue)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Magenta") == 0) {
+			if(_set_color_sequence(ptr, colortab->magenta)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "Cyan") == 0) {
+			if(_set_color_sequence(ptr, colortab->cyan)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else if(strcmp(key, "White") == 0) {
+			if(_set_color_sequence(ptr, colortab->white)) {
+				pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: color '%s' not recognized.\n"),
+							file, linenum, ptr);
+			}
+		} else {
+			pm_printf(ALPM_LOG_ERROR, _("config file %s, line %d: directive '%s' not recognized.\n"),
+					file, linenum, key);
+			return(1);
+		}
+	}
+	return(0);
+}
+
+int parsecolorconfig()
+{
+	return(_parsecolorconfig(&colortab, "/etc/pacman.d/color.conf"));
+}
+
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args)
+{
+	int ret = 0;
+
+	if(isatty(fileno(stream)) && colors) {
+		char* msg = NULL;
+		ret = vasprintf(&msg, format, args);
+		if(msg == NULL) {
+			return(ret);
+		}
+
+		const colordata_t* colorpos = colors;
+		color_t colorlast = COLOR_NONE;
+		int len = strlen(msg) + 1;
+		wchar_t* wcstr = calloc(len, sizeof(wchar_t));
+		len = mbstowcs(wcstr, msg, len);
+		free(msg);
+		const wchar_t *strpos = wcstr;
+		
+		while(*strpos) {
+			if(colorpos->color != COLOR_END &&
+				((colorpos->separator == SEP_ANY) ||
+				 (colorpos->separator == SEP_LINE && *strpos == L'\n') ||
+				 (colorpos->separator == SEP_COLON && (*strpos == L':' || *strpos == L'：')))) {
+				_insert_color(stream, colorpos->color);
+				colorlast = colorpos->color;
+				colorpos++;
+			}
+			fprintf(stream, "%lc", (wint_t)*strpos);
+			strpos++;
+		}
+		free(wcstr);
+
+		if(colorlast != COLOR_NONE) {
+			_insert_color(stream, COLOR_NONE);
+		}
+	} else {
+		ret = vfprintf(stream, format, args);
+	}
+	return(ret);
+}
+
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stream, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+int color_printf(const colordata_t* colors, const char* format, ...)
+{
+	int ret;
+	va_list args;
+	va_start(args, format);
+	ret = color_vfprintf(stdout, colors, format, args);
+	va_end(args);
+	return(ret);
+}
+
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string)
+{
+	if(title) {
+		color_printf(colors_title, "%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		color_printf(colors_string, "%s", string);
+	}
+	printf("\n");
+}
+
+const colordata_t COLOR_WHITE_ALL[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_GREEN_ALL[] = {
+	{ SEP_ANY, COLOR_GREEN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_RED_ALL[] = {
+	{ SEP_ANY, COLOR_RED },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_BLUE_ALL[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_YELLOW_ALL[] = {
+	{ SEP_ANY, COLOR_YELLOW },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_MAGENTA_ALL[] = {
+	{ SEP_ANY, COLOR_MAGENTA },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_CYAN_ALL[] = {
+	{ SEP_ANY, COLOR_CYAN },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_DOUBLECOLON2[] = {
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_BLUE },
+	{ SEP_ANY, COLOR_SAME },
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_LINE, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
+const colordata_t COLOR_WHITE_COLON[] = {
+	{ SEP_ANY, COLOR_WHITE },
+	{ SEP_COLON, COLOR_SAME },
+	{ SEP_ANY, COLOR_NONE },
+	{ SEP_ANY, COLOR_END } };
+
 /* vim: set ts=2 sw=2 noet: */
diff -Npaur a/src/pacman/util.c.orig b/src/pacman/util.c.orig
--- a/src/pacman/util.c.orig	1970-01-01 02:00:00.000000000 +0200
+++ b/src/pacman/util.c.orig	2012-04-11 18:50:50.776479963 +0300
@@ -0,0 +1,1569 @@
+/*
+ *  util.c
+ *
+ *  Copyright (c) 2006-2012 Pacman Development Team <pacman-dev@archlinux.org>
+ *  Copyright (c) 2002-2006 by Judd Vinet <jvinet@zeroflux.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "config.h"
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <stdint.h> /* intmax_t */
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <limits.h>
+#include <wchar.h>
+#ifdef HAVE_TERMIOS_H
+#include <termios.h> /* tcflush */
+#endif
+
+#include <alpm.h>
+#include <alpm_list.h>
+
+/* pacman */
+#include "util.h"
+#include "conf.h"
+#include "callback.h"
+
+
+int trans_init(alpm_transflag_t flags, int check_valid)
+{
+	int ret;
+
+	check_syncdbs(0, check_valid);
+
+	ret = alpm_trans_init(config->handle, flags);
+	if(ret == -1) {
+		trans_init_error();
+		return -1;
+	}
+	return 0;
+}
+
+void trans_init_error(void)
+{
+	enum _alpm_errno_t err = alpm_errno(config->handle);
+	pm_printf(ALPM_LOG_ERROR, _("failed to init transaction (%s)\n"),
+			alpm_strerror(err));
+	if(err == ALPM_ERR_HANDLE_LOCK) {
+		const char *lockfile = alpm_option_get_lockfile(config->handle);
+		pm_printf(ALPM_LOG_ERROR, _("could not lock database: %s\n"),
+					strerror(errno));
+		if(access(lockfile, F_OK) == 0) {
+			fprintf(stderr, _("  if you're sure a package manager is not already\n"
+						"  running, you can remove %s\n"), lockfile);
+		}
+	}
+}
+
+int trans_release(void)
+{
+	if(alpm_trans_release(config->handle) == -1) {
+		pm_printf(ALPM_LOG_ERROR, _("failed to release transaction (%s)\n"),
+				alpm_strerror(alpm_errno(config->handle)));
+		return -1;
+	}
+	return 0;
+}
+
+int needs_root(void)
+{
+	switch(config->op) {
+		case PM_OP_DATABASE:
+			return 1;
+		case PM_OP_UPGRADE:
+		case PM_OP_REMOVE:
+			return !config->print;
+		case PM_OP_SYNC:
+			return (config->op_s_clean || config->op_s_sync ||
+					(!config->group && !config->op_s_info && !config->op_q_list &&
+					 !config->op_s_search && !config->print));
+		default:
+			return 0;
+	}
+}
+
+int check_syncdbs(size_t need_repos, int check_valid)
+{
+	int ret = 0;
+	alpm_list_t *i;
+	alpm_list_t *sync_dbs = alpm_option_get_syncdbs(config->handle);
+
+	if(need_repos && sync_dbs == NULL) {
+		pm_printf(ALPM_LOG_ERROR, _("no usable package repositories configured.\n"));
+		return 1;
+	}
+
+	if(check_valid) {
+		/* ensure all known dbs are valid */
+		for(i = sync_dbs; i; i = alpm_list_next(i)) {
+			alpm_db_t *db = i->data;
+			if(alpm_db_get_valid(db)) {
+				pm_printf(ALPM_LOG_ERROR, _("database '%s' is not valid (%s)\n"),
+						alpm_db_get_name(db), alpm_strerror(alpm_errno(config->handle)));
+				ret = 1;
+			}
+		}
+	}
+	return ret;
+}
+
+/* discard unhandled input on the terminal's input buffer */
+static int flush_term_input(void) {
+#ifdef HAVE_TCFLUSH
+	if(isatty(fileno(stdin))) {
+		return tcflush(fileno(stdin), TCIFLUSH);
+	}
+#endif
+
+	/* fail silently */
+	return 0;
+}
+
+/* gets the current screen column width */
+unsigned short getcols(void)
+{
+	const unsigned short default_tty = 80;
+	const unsigned short default_notty = 0;
+	unsigned short termwidth = 0;
+
+	if(!isatty(fileno(stdout))) {
+		return default_notty;
+	}
+
+#ifdef TIOCGSIZE
+	struct ttysize win;
+	if(ioctl(1, TIOCGSIZE, &win) == 0) {
+		termwidth = win.ts_cols;
+	}
+#elif defined(TIOCGWINSZ)
+	struct winsize win;
+	if(ioctl(1, TIOCGWINSZ, &win) == 0) {
+		termwidth = win.ws_col;
+	}
+#endif
+	return termwidth == 0 ? default_tty : termwidth;
+}
+
+/* does the same thing as 'rm -rf' */
+int rmrf(const char *path)
+{
+	int errflag = 0;
+	struct dirent *dp;
+	DIR *dirp;
+
+	if(!unlink(path)) {
+		return 0;
+	} else {
+		if(errno == ENOENT) {
+			return 0;
+		} else if(errno == EPERM) {
+			/* fallthrough */
+		} else if(errno == EISDIR) {
+			/* fallthrough */
+		} else if(errno == ENOTDIR) {
+			return 1;
+		} else {
+			/* not a directory */
+			return 1;
+		}
+
+		dirp = opendir(path);
+		if(!dirp) {
+			return 1;
+		}
+		for(dp = readdir(dirp); dp != NULL; dp = readdir(dirp)) {
+			if(dp->d_name) {
+				if(strcmp(dp->d_name, "..") != 0 && strcmp(dp->d_name, ".") != 0) {
+					char name[PATH_MAX];
+					snprintf(name, PATH_MAX, "%s/%s", path, dp->d_name);
+					errflag += rmrf(name);
+				}
+			}
+		}
+		closedir(dirp);
+		if(rmdir(path)) {
+			errflag++;
+		}
+		return errflag;
+	}
+}
+
+/** Parse the basename of a program from a path.
+* @param path path to parse basename from
+*
+* @return everything following the final '/'
+*/
+const char *mbasename(const char *path)
+{
+	const char *last = strrchr(path, '/');
+	if(last) {
+		return last + 1;
+	}
+	return path;
+}
+
+/** Parse the dirname of a program from a path.
+* The path returned should be freed.
+* @param path path to parse dirname from
+*
+* @return everything preceding the final '/'
+*/
+char *mdirname(const char *path)
+{
+	char *ret, *last;
+
+	/* null or empty path */
+	if(path == NULL || path == '\0') {
+		return strdup(".");
+	}
+
+	ret = strdup(path);
+	last = strrchr(ret, '/');
+
+	if(last != NULL) {
+		/* we found a '/', so terminate our string */
+		*last = '\0';
+		return ret;
+	}
+	/* no slash found */
+	free(ret);
+	return strdup(".");
+}
+
+/* output a string, but wrap words properly with a specified indentation
+ */
+void indentprint(const char *str, size_t indent)
+{
+	wchar_t *wcstr;
+	const wchar_t *p;
+	int len, cidx;
+	const unsigned short cols = getcols();
+
+	if(!str) {
+		return;
+	}
+
+	/* if we're not a tty, or our tty is not wide enough that wrapping even makes
+	 * sense, print without indenting */
+	if(cols == 0 || indent > cols) {
+		printf("%s", str);
+		return;
+	}
+
+	len = strlen(str) + 1;
+	wcstr = calloc(len, sizeof(wchar_t));
+	len = mbstowcs(wcstr, str, len);
+	p = wcstr;
+	cidx = indent;
+
+	if(!p || !len) {
+		return;
+	}
+
+	while(*p) {
+		if(*p == L' ') {
+			const wchar_t *q, *next;
+			p++;
+			if(p == NULL || *p == L' ') continue;
+			next = wcschr(p, L' ');
+			if(next == NULL) {
+				next = p + wcslen(p);
+			}
+			/* len captures # cols */
+			len = 0;
+			q = p;
+			while(q < next) {
+				len += wcwidth(*q++);
+			}
+			if(len > (cols - cidx - 1)) {
+				/* wrap to a newline and reindent */
+				printf("\n%-*s", (int)indent, "");
+				cidx = indent;
+			} else {
+				printf(" ");
+				cidx++;
+			}
+			continue;
+		}
+		printf("%lc", (wint_t)*p);
+		cidx += wcwidth(*p);
+		p++;
+	}
+	free(wcstr);
+}
+
+/* Trim whitespace and newlines from a string
+ */
+char *strtrim(char *str)
+{
+	char *pch = str;
+
+	if(str == NULL || *str == '\0') {
+		/* string is empty, so we're done. */
+		return str;
+	}
+
+	while(isspace((unsigned char)*pch)) {
+		pch++;
+	}
+	if(pch != str) {
+		size_t len = strlen(pch);
+		if(len) {
+			memmove(str, pch, len + 1);
+		} else {
+			*str = '\0';
+		}
+	}
+
+	/* check if there wasn't anything but whitespace in the string. */
+	if(*str == '\0') {
+		return str;
+	}
+
+	pch = (str + (strlen(str) - 1));
+	while(isspace((unsigned char)*pch)) {
+		pch--;
+	}
+	*++pch = '\0';
+
+	return str;
+}
+
+/* Replace all occurances of 'needle' with 'replace' in 'str', returning
+ * a new string (must be free'd) */
+char *strreplace(const char *str, const char *needle, const char *replace)
+{
+	const char *p = NULL, *q = NULL;
+	char *newstr = NULL, *newp = NULL;
+	alpm_list_t *i = NULL, *list = NULL;
+	size_t needlesz = strlen(needle), replacesz = strlen(replace);
+	size_t newsz;
+
+	if(!str) {
+		return NULL;
+	}
+
+	p = str;
+	q = strstr(p, needle);
+	while(q) {
+		list = alpm_list_add(list, (char *)q);
+		p = q + needlesz;
+		q = strstr(p, needle);
+	}
+
+	/* no occurences of needle found */
+	if(!list) {
+		return strdup(str);
+	}
+	/* size of new string = size of old string + "number of occurences of needle"
+	 * x "size difference between replace and needle" */
+	newsz = strlen(str) + 1 +
+		alpm_list_count(list) * (replacesz - needlesz);
+	newstr = calloc(newsz, sizeof(char));
+	if(!newstr) {
+		return NULL;
+	}
+
+	p = str;
+	newp = newstr;
+	for(i = list; i; i = alpm_list_next(i)) {
+		q = alpm_list_getdata(i);
+		if(q > p) {
+			/* add chars between this occurence and last occurence, if any */
+			memcpy(newp, p, (size_t)(q - p));
+			newp += q - p;
+		}
+		memcpy(newp, replace, replacesz);
+		newp += replacesz;
+		p = q + needlesz;
+	}
+	alpm_list_free(list);
+
+	if(*p) {
+		/* add the rest of 'p' */
+		strcpy(newp, p);
+	}
+
+	return newstr;
+}
+
+/** Splits a string into a list of strings using the chosen character as
+ * a delimiter.
+ *
+ * @param str the string to split
+ * @param splitchar the character to split at
+ *
+ * @return a list containing the duplicated strings
+ */
+alpm_list_t *strsplit(const char *str, const char splitchar)
+{
+	alpm_list_t *list = NULL;
+	const char *prev = str;
+	char *dup = NULL;
+
+	while((str = strchr(str, splitchar))) {
+		dup = strndup(prev, (size_t)(str - prev));
+		if(dup == NULL) {
+			return NULL;
+		}
+		list = alpm_list_add(list, dup);
+
+		str++;
+		prev = str;
+	}
+
+	dup = strdup(prev);
+	if(dup == NULL) {
+		return NULL;
+	}
+	list = alpm_list_add(list, dup);
+
+	return list;
+}
+
+static size_t string_length(const char *s)
+{
+	int len;
+	wchar_t *wcstr;
+
+	if(!s || s[0] == '\0') {
+		return 0;
+	}
+	/* len goes from # bytes -> # chars -> # cols */
+	len = strlen(s) + 1;
+	wcstr = calloc(len, sizeof(wchar_t));
+	len = mbstowcs(wcstr, s, len);
+	len = wcswidth(wcstr, len);
+	free(wcstr);
+
+	return len;
+}
+
+void string_display(const char *title, const char *string)
+{
+	if(title) {
+		printf("%s ", title);
+	}
+	if(string == NULL || string[0] == '\0') {
+		printf(_("None"));
+	} else {
+		/* compute the length of title + a space */
+		size_t len = string_length(title) + 1;
+		indentprint(string, len);
+	}
+	printf("\n");
+}
+
+static void table_print_line(const alpm_list_t *line,
+		size_t colcount, size_t *widths)
+{
+	size_t i;
+	const alpm_list_t *curcell;
+
+	for(i = 0, curcell = line; curcell && i < colcount;
+			i++, curcell = alpm_list_next(curcell)) {
+		const char *value = curcell->data;
+		size_t len = string_length(value);
+		/* silly printf requires padding size to be an int */
+		int padding = (int)widths[i] - (int)len;
+		if(padding < 0) {
+			padding = 0;
+		}
+		/* left-align all but the last column */
+		if(i + 1 < colcount) {
+			printf("%s%*s", value, padding, "");
+		} else {
+			printf("%*s%s", padding, "", value);
+		}
+	}
+
+	printf("\n");
+}
+
+/* find the max string width of each column */
+static size_t table_calc_widths(const alpm_list_t *header,
+		const alpm_list_t *rows, size_t totalcols, size_t **widths)
+{
+	const alpm_list_t *i;
+	const unsigned short padding = 2;
+	size_t curcol, totalwidth = 0;
+	size_t *colwidths;
+
+	if(totalcols <= 0) {
+		return 0;
+	}
+
+	colwidths = malloc(totalcols * sizeof(size_t));
+	if(!colwidths) {
+		return 0;
+	}
+	/* header determines column count and initial values of longest_strs */
+	for(i = header, curcol = 0; i; i = alpm_list_next(i), curcol++) {
+		colwidths[curcol] = string_length(alpm_list_getdata(i));
+	}
+
+	/* now find the longest string in each column */
+	for(i = rows; i; i = alpm_list_next(i)) {
+		/* grab first column of each row and iterate through columns */
+		const alpm_list_t *j = alpm_list_getdata(i);
+		for(curcol = 0; j; j = alpm_list_next(j), curcol++) {
+			char *str = alpm_list_getdata(j);
+			size_t str_len = string_length(str);
+
+			if(str_len > colwidths[curcol]) {
+				colwidths[curcol] = str_len;
+			}
+		}
+	}
+
+	for(i = header, curcol = 0; i; i = alpm_list_next(i), curcol++) {
+		/* pad everything but the last column */
+		if(curcol + 1 < totalcols) {
+			colwidths[curcol] += padding;
+		}
+		totalwidth += colwidths[curcol];
+	}
+
+	*widths = colwidths;
+	return totalwidth;
+}
+
+/** Displays the list in table format
+ *
+ * @param title the tables title
+ * @param header the column headers. column count is determined by the nr
+ *               of headers
+ * @param rows the rows to display as a list of lists of strings. the outer
+ *             list represents the rows, the inner list the cells (= columns)
+ *
+ * @return -1 if not enough terminal cols available, else 0
+ */
+int table_display(const char *title, const alpm_list_t *header,
+		const alpm_list_t *rows)
+{
+	const alpm_list_t *i;
+	size_t *widths = NULL, totalcols, totalwidth;
+
+	if(rows == NULL || header == NULL) {
+		return 0;
+	}
+
+	totalcols = alpm_list_count(header);
+	totalwidth = table_calc_widths(header, rows, totalcols, &widths);
+	/* return -1 if terminal is not wide enough */
+	if(totalwidth > getcols()) {
+		pm_printf(ALPM_LOG_WARNING,
+				_("insufficient columns available for table display\n"));
+		return -1;
+	}
+	if(!totalwidth || !widths) {
+		return -1;
+	}
+
+	if(title != NULL) {
+		printf("%s\n\n", title);
+	}
+
+	table_print_line(header, totalcols, widths);
+	printf("\n");
+
+	for(i = rows; i; i = alpm_list_next(i)) {
+		table_print_line(alpm_list_getdata(i), totalcols, widths);
+	}
+
+	free(widths);
+	return 0;
+}
+
+void list_display(const char *title, const alpm_list_t *list)
+{
+	const alpm_list_t *i;
+	size_t len = 0;
+
+	if(title) {
+		len = string_length(title) + 1;
+		printf("%s ", title);
+	}
+
+	if(!list) {
+		printf("%s\n", _("None"));
+	} else {
+		const unsigned short maxcols = getcols();
+		size_t cols = len;
+		const char *str = alpm_list_getdata(list);
+		printf("%s", str);
+		cols += string_length(str);
+		for(i = alpm_list_next(list); i; i = alpm_list_next(i)) {
+			str = alpm_list_getdata(i);
+			size_t s = string_length(str);
+			/* wrap only if we have enough usable column space */
+			if(maxcols > len && cols + s + 2 >= maxcols) {
+				size_t j;
+				cols = len;
+				printf("\n");
+				for (j = 1; j <= len; j++) {
+					printf(" ");
+				}
+			} else if(cols != len) {
+				/* 2 spaces are added if this is not the first element on a line. */
+				printf("  ");
+				cols += 2;
+			}
+			printf("%s", str);
+			cols += s;
+		}
+		printf("\n");
+	}
+}
+
+void list_display_linebreak(const char *title, const alpm_list_t *list)
+{
+	size_t len = 0;
+
+	if(title) {
+		len = string_length(title) + 1;
+		printf("%s ", title);
+	}
+
+	if(!list) {
+		printf("%s\n", _("None"));
+	} else {
+		const alpm_list_t *i;
+		/* Print the first element */
+		indentprint((const char *) alpm_list_getdata(list), len);
+		printf("\n");
+		/* Print the rest */
+		for(i = alpm_list_next(list); i; i = alpm_list_next(i)) {
+			size_t j;
+			for(j = 1; j <= len; j++) {
+				printf(" ");
+			}
+			indentprint((const char *) alpm_list_getdata(i), len);
+			printf("\n");
+		}
+	}
+}
+
+void signature_display(const char *title, alpm_siglist_t *siglist)
+{
+	size_t len = 0;
+
+	if(title) {
+		len = string_length(title) + 1;
+		printf("%s ", title);
+	}
+	if(siglist->count == 0) {
+		printf(_("None"));
+	} else {
+		size_t i;
+		for(i = 0; i < siglist->count; i++) {
+			char *sigline;
+			const char *status, *validity, *name;
+			int ret;
+			alpm_sigresult_t *result = siglist->results + i;
+			/* Don't re-indent the first result */
+			if(i != 0) {
+				size_t j;
+				for(j = 1; j <= len; j++) {
+					printf(" ");
+				}
+			}
+			switch(result->status) {
+				case ALPM_SIGSTATUS_VALID:
+					status = _("Valid");
+					break;
+				case ALPM_SIGSTATUS_KEY_EXPIRED:
+					status = _("Key expired");
+					break;
+				case ALPM_SIGSTATUS_SIG_EXPIRED:
+					status = _("Expired");
+					break;
+				case ALPM_SIGSTATUS_INVALID:
+					status = _("Invalid");
+					break;
+				case ALPM_SIGSTATUS_KEY_UNKNOWN:
+					status = _("Key unknown");
+					break;
+				case ALPM_SIGSTATUS_KEY_DISABLED:
+					status = _("Key disabled");
+					break;
+				default:
+					status = _("Signature error");
+					break;
+			}
+			switch(result->validity) {
+				case ALPM_SIGVALIDITY_FULL:
+					validity = _("full trust");
+					break;
+				case ALPM_SIGVALIDITY_MARGINAL:
+					validity = _("marginal trust");
+					break;
+				case ALPM_SIGVALIDITY_NEVER:
+					validity = _("never trust");
+					break;
+				case ALPM_SIGVALIDITY_UNKNOWN:
+				default:
+					validity = _("unknown trust");
+					break;
+			}
+			name = result->key.uid ? result->key.uid : result->key.fingerprint;
+			ret = pm_asprintf(&sigline, _("%s, %s from \"%s\""),
+					status, validity, name);
+			if(ret == -1) {
+				pm_printf(ALPM_LOG_ERROR,  _("failed to allocate string\n"));
+				continue;
+			}
+			indentprint(sigline, len);
+			printf("\n");
+			free(sigline);
+		}
+	}
+}
+
+/* creates a header row for use with table_display */
+static alpm_list_t *create_verbose_header(int dl_size)
+{
+	alpm_list_t *res = NULL;
+	char *str;
+
+	str = _("Name");
+	res = alpm_list_add(res, str);
+	str = _("Old Version");
+	res = alpm_list_add(res, str);
+	str = _("New Version");
+	res = alpm_list_add(res, str);
+	str = _("Net Change");
+	res = alpm_list_add(res, str);
+	if(dl_size) {
+		str = _("Download Size");
+		res = alpm_list_add(res, str);
+	}
+
+	return res;
+}
+
+/* returns package info as list of strings */
+static alpm_list_t *create_verbose_row(pm_target_t *target, int dl_size)
+{
+	char *str;
+	off_t size = 0;
+	double human_size;
+	const char *label;
+	alpm_list_t *ret = NULL;
+
+	/* a row consists of the package name, */
+	if(target->install) {
+		pm_asprintf(&str, "%s", alpm_pkg_get_name(target->install));
+	} else {
+		pm_asprintf(&str, "%s", alpm_pkg_get_name(target->remove));
+	}
+	ret = alpm_list_add(ret, str);
+
+	/* old and new versions */
+	pm_asprintf(&str, "%s",
+			target->remove != NULL ? alpm_pkg_get_version(target->remove) : "");
+	ret = alpm_list_add(ret, str);
+
+	pm_asprintf(&str, "%s",
+			target->install != NULL ? alpm_pkg_get_version(target->install) : "");
+	ret = alpm_list_add(ret, str);
+
+	/* and size */
+	size -= target->remove ? alpm_pkg_get_isize(target->remove) : 0;
+	size += target->install ? alpm_pkg_get_isize(target->install) : 0;
+	human_size = humanize_size(size, 'M', 2, &label);
+	pm_asprintf(&str, "%.2f %s", human_size, label);
+	ret = alpm_list_add(ret, str);
+
+	if(dl_size) {
+		size = target->install ? alpm_pkg_download_size(target->install) : 0;
+		human_size = humanize_size(size, 'M', 2, &label);
+		if(size != 0) {
+			pm_asprintf(&str, "%.2f %s", human_size, label);
+		} else {
+			str = strdup("");
+		}
+		ret = alpm_list_add(ret, str);
+	}
+
+	return ret;
+}
+
+/* prepare a list of pkgs to display */
+static void _display_targets(alpm_list_t *targets, int verbose)
+{
+	char *str;
+	const char *label;
+	double size;
+	off_t isize = 0, rsize = 0, dlsize = 0;
+	alpm_list_t *i, *rows = NULL, *names = NULL;
+	int show_dl_size = config->op == PM_OP_SYNC;
+
+	if(!targets) {
+		return;
+	}
+
+	/* gather package info */
+	for(i = targets; i; i = alpm_list_next(i)) {
+		pm_target_t *target = alpm_list_getdata(i);
+
+		if(target->install) {
+			dlsize += alpm_pkg_download_size(target->install);
+			isize += alpm_pkg_get_isize(target->install);
+		}
+		if(target->remove) {
+			/* add up size of all removed packages */
+			rsize += alpm_pkg_get_isize(target->remove);
+		}
+	}
+
+	/* form data for both verbose and non-verbose display */
+	for(i = targets; i; i = alpm_list_next(i)) {
+		pm_target_t *target = i->data;
+
+		rows = alpm_list_add(rows, create_verbose_row(target, show_dl_size));
+		if(target->install) {
+			pm_asprintf(&str, "%s-%s", alpm_pkg_get_name(target->install),
+					alpm_pkg_get_version(target->install));
+		} else if(isize == 0) {
+			pm_asprintf(&str, "%s-%s", alpm_pkg_get_name(target->remove),
+					alpm_pkg_get_version(target->remove));
+		} else {
+			pm_asprintf(&str, "%s-%s [removal]", alpm_pkg_get_name(target->remove),
+					alpm_pkg_get_version(target->remove));
+		}
+		names = alpm_list_add(names, str);
+	}
+
+	/* print to screen */
+	pm_asprintf(&str, _("Targets (%d):"), alpm_list_count(targets));
+
+	printf("\n");
+	if(verbose) {
+		alpm_list_t *header = create_verbose_header(show_dl_size);
+		if(table_display(str, header, rows) != 0) {
+			/* fallback to list display if table wouldn't fit */
+			list_display(str, names);
+		}
+		alpm_list_free(header);
+	} else {
+		list_display(str, names);
+	}
+	printf("\n");
+
+	/* rows is a list of lists of strings, free inner lists here */
+	for(i = rows; i; i = alpm_list_next(i)) {
+		alpm_list_t *lp = alpm_list_getdata(i);
+		FREELIST(lp);
+	}
+	alpm_list_free(rows);
+	FREELIST(names);
+	free(str);
+
+	if(dlsize > 0 || config->op_s_downloadonly) {
+		size = humanize_size(dlsize, 'M', 2, &label);
+		printf(_("Total Download Size:    %.2f %s\n"), size, label);
+	}
+	if(!config->op_s_downloadonly) {
+		if(isize > 0) {
+			size = humanize_size(isize, 'M', 2, &label);
+			printf(_("Total Installed Size:   %.2f %s\n"), size, label);
+		}
+		if(rsize > 0 && isize == 0) {
+			size = humanize_size(rsize, 'M', 2, &label);
+			printf(_("Total Removed Size:     %.2f %s\n"), size, label);
+		}
+		/* only show this net value if different from raw installed size */
+		if(isize > 0 && rsize > 0) {
+			size = humanize_size(isize - rsize, 'M', 2, &label);
+			printf(_("Net Upgrade Size:       %.2f %s\n"), size, label);
+		}
+	}
+}
+
+static int target_cmp(const void *p1, const void *p2)
+{
+	const pm_target_t *targ1 = p1;
+	const pm_target_t *targ2 = p2;
+	/* explicit are always sorted after implicit (e.g. deps, pulled targets) */
+	if(targ1->is_explicit != targ2->is_explicit) {
+		return targ1->is_explicit > targ2->is_explicit;
+	}
+	const char *name1 = targ1->install ?
+		alpm_pkg_get_name(targ1->install) : alpm_pkg_get_name(targ1->remove);
+	const char *name2 = targ2->install ?
+		alpm_pkg_get_name(targ2->install) : alpm_pkg_get_name(targ2->remove);
+	return strcmp(name1, name2);
+}
+
+static int pkg_cmp(const void *p1, const void *p2)
+{
+	/* explicit cast due to (un)necessary removal of const */
+	alpm_pkg_t *pkg1 = (alpm_pkg_t *)p1;
+	alpm_pkg_t *pkg2 = (alpm_pkg_t *)p2;
+	return strcmp(alpm_pkg_get_name(pkg1), alpm_pkg_get_name(pkg2));
+}
+
+void display_targets(void)
+{
+	alpm_list_t *i, *targets = NULL;
+	alpm_db_t *db_local = alpm_option_get_localdb(config->handle);
+
+	for(i = alpm_trans_get_add(config->handle); i; i = alpm_list_next(i)) {
+		alpm_pkg_t *pkg = alpm_list_getdata(i);
+		pm_target_t *targ = calloc(1, sizeof(pm_target_t));
+		if(!targ) return;
+		targ->install = pkg;
+		targ->remove = alpm_db_get_pkg(db_local, alpm_pkg_get_name(pkg));
+		if(alpm_list_find(config->explicit_adds, pkg, pkg_cmp)) {
+			targ->is_explicit = 1;
+		}
+		targets = alpm_list_add(targets, targ);
+	}
+	for(i = alpm_trans_get_remove(config->handle); i; i = alpm_list_next(i)) {
+		alpm_pkg_t *pkg = alpm_list_getdata(i);
+		pm_target_t *targ = calloc(1, sizeof(pm_target_t));
+		if(!targ) return;
+		targ->remove = pkg;
+		if(alpm_list_find(config->explicit_removes, pkg, pkg_cmp)) {
+			targ->is_explicit = 1;
+		}
+		targets = alpm_list_add(targets, targ);
+	}
+
+	targets = alpm_list_msort(targets, alpm_list_count(targets), target_cmp);
+	_display_targets(targets, config->verbosepkglists);
+	FREELIST(targets);
+}
+
+static off_t pkg_get_size(alpm_pkg_t *pkg)
+{
+	switch(config->op) {
+		case PM_OP_SYNC:
+			return alpm_pkg_download_size(pkg);
+		case PM_OP_UPGRADE:
+			return alpm_pkg_get_size(pkg);
+		default:
+			return alpm_pkg_get_isize(pkg);
+	}
+}
+
+static char *pkg_get_location(alpm_pkg_t *pkg)
+{
+	alpm_list_t *servers;
+	char *string = NULL;
+	switch(config->op) {
+		case PM_OP_SYNC:
+			servers = alpm_db_get_servers(alpm_pkg_get_db(pkg));
+			if(servers) {
+				pm_asprintf(&string, "%s/%s", alpm_list_getdata(servers),
+						alpm_pkg_get_filename(pkg));
+				return string;
+			}
+		case PM_OP_UPGRADE:
+			return strdup(alpm_pkg_get_filename(pkg));
+		default:
+			pm_asprintf(&string, "%s-%s", alpm_pkg_get_name(pkg), alpm_pkg_get_version(pkg));
+			return string;
+	}
+}
+
+/* a pow() implementation that is specialized for an integer base and small,
+ * positive-only integer exponents. */
+static double simple_pow(int base, int exp)
+{
+	double result = 1.0;
+	for(; exp > 0; exp--) {
+		result *= base;
+	}
+	return result;
+}
+
+/** Converts sizes in bytes into human readable units.
+ *
+ * @param bytes the size in bytes
+ * @param target_unit '\0' or a short label. If equal to one of the short unit
+ * labels ('B', 'K', ...) bytes is converted to target_unit; if '\0', the first
+ * unit which will bring the value to below a threshold of 2048 will be chosen.
+ * @param precision number of decimal places, ensures -0.00 gets rounded to
+ * 0.00; -1 if no rounding desired
+ * @param label will be set to the appropriate unit label
+ *
+ * @return the size in the appropriate unit
+ */
+double humanize_size(off_t bytes, const char target_unit, int precision,
+		const char **label)
+{
+	static const char *labels[] = {"B", "KiB", "MiB", "GiB",
+		"TiB", "PiB", "EiB", "ZiB", "YiB"};
+	static const int unitcount = sizeof(labels) / sizeof(labels[0]);
+
+	double val = (double)bytes;
+	int index;
+
+	for(index = 0; index < unitcount - 1; index++) {
+		if(target_unit != '\0' && labels[index][0] == target_unit) {
+			break;
+		} else if(target_unit == '\0' && val <= 2048.0 && val >= -2048.0) {
+			break;
+		}
+		val /= 1024.0;
+	}
+
+	if(label) {
+		*label = labels[index];
+	}
+
+	/* fix FS#27924 so that it doesn't display negative zeroes */
+	if(precision >= 0 && val < 0.0 &&
+			val > (-0.5 / simple_pow(10, precision))) {
+		val = 0.0;
+	}
+
+	return val;
+}
+
+void print_packages(const alpm_list_t *packages)
+{
+	const alpm_list_t *i;
+	if(!config->print_format) {
+		config->print_format = strdup("%l");
+	}
+	for(i = packages; i; i = alpm_list_next(i)) {
+		alpm_pkg_t *pkg = alpm_list_getdata(i);
+		char *string = strdup(config->print_format);
+		char *temp = string;
+		/* %n : pkgname */
+		if(strstr(temp, "%n")) {
+			string = strreplace(temp, "%n", alpm_pkg_get_name(pkg));
+			free(temp);
+			temp = string;
+		}
+		/* %v : pkgver */
+		if(strstr(temp, "%v")) {
+			string = strreplace(temp, "%v", alpm_pkg_get_version(pkg));
+			free(temp);
+			temp = string;
+		}
+		/* %l : location */
+		if(strstr(temp, "%l")) {
+			char *pkgloc = pkg_get_location(pkg);
+			string = strreplace(temp, "%l", pkgloc);
+			free(pkgloc);
+			free(temp);
+			temp = string;
+		}
+		/* %r : repo */
+		if(strstr(temp, "%r")) {
+			const char *repo = "local";
+			alpm_db_t *db = alpm_pkg_get_db(pkg);
+			if(db) {
+				repo = alpm_db_get_name(db);
+			}
+			string = strreplace(temp, "%r", repo);
+			free(temp);
+			temp = string;
+		}
+		/* %s : size */
+		if(strstr(temp, "%s")) {
+			char *size;
+			pm_asprintf(&size, "%jd", (intmax_t)pkg_get_size(pkg));
+			string = strreplace(temp, "%s", size);
+			free(size);
+			free(temp);
+		}
+		printf("%s\n",string);
+		free(string);
+	}
+}
+
+/* Helper function for comparing strings using the
+ * alpm "compare func" signature */
+int str_cmp(const void *s1, const void *s2)
+{
+	return strcmp(s1, s2);
+}
+
+void display_new_optdepends(alpm_pkg_t *oldpkg, alpm_pkg_t *newpkg)
+{
+	alpm_list_t *old = alpm_pkg_get_optdepends(oldpkg);
+	alpm_list_t *new = alpm_pkg_get_optdepends(newpkg);
+	alpm_list_t *optdeps = alpm_list_diff(new,old,str_cmp);
+	if(optdeps) {
+		printf(_("New optional dependencies for %s\n"), alpm_pkg_get_name(newpkg));
+		list_display_linebreak("   ", optdeps);
+	}
+	alpm_list_free(optdeps);
+}
+
+void display_optdepends(alpm_pkg_t *pkg)
+{
+	alpm_list_t *optdeps = alpm_pkg_get_optdepends(pkg);
+	if(optdeps) {
+		printf(_("Optional dependencies for %s\n"), alpm_pkg_get_name(pkg));
+		list_display_linebreak("   ", optdeps);
+	}
+}
+
+static void display_repo_list(const char *dbname, alpm_list_t *list)
+{
+	const char *prefix= "  ";
+
+	printf(":: ");
+	printf(_("Repository %s\n"), dbname);
+	list_display(prefix, list);
+}
+
+void select_display(const alpm_list_t *pkglist)
+{
+	const alpm_list_t *i;
+	int nth = 1;
+	alpm_list_t *list = NULL;
+	char *string = NULL;
+	const char *dbname = NULL;
+
+	for (i = pkglist; i; i = i->next) {
+		alpm_pkg_t *pkg = alpm_list_getdata(i);
+		alpm_db_t *db = alpm_pkg_get_db(pkg);
+
+		if(!dbname)
+			dbname = alpm_db_get_name(db);
+		if(strcmp(alpm_db_get_name(db), dbname) != 0) {
+			display_repo_list(dbname, list);
+			FREELIST(list);
+			dbname = alpm_db_get_name(db);
+		}
+		string = NULL;
+		pm_asprintf(&string, "%d) %s", nth, alpm_pkg_get_name(pkg));
+		list = alpm_list_add(list, string);
+		nth++;
+	}
+	display_repo_list(dbname, list);
+	FREELIST(list);
+}
+
+static int parseindex(char *s, int *val, int min, int max)
+{
+	char *endptr = NULL;
+	int n = strtol(s, &endptr, 10);
+	if(*endptr == '\0') {
+		if(n < min || n > max) {
+			pm_printf(ALPM_LOG_ERROR,
+					_("invalid value: %d is not between %d and %d\n"),
+					n, min, max);
+			return -1;
+		}
+		*val = n;
+		return 0;
+	} else {
+		pm_printf(ALPM_LOG_ERROR, _("invalid number: %s\n"), s);
+		return -1;
+	}
+}
+
+static int multiselect_parse(char *array, int count, char *response)
+{
+	char *str, *saveptr;
+
+	for (str = response; ; str = NULL) {
+		int include = 1;
+		int start, end;
+		char *ends = NULL;
+		char *starts = strtok_r(str, " ", &saveptr);
+
+		if(starts == NULL) {
+			break;
+		}
+		strtrim(starts);
+		int len = strlen(starts);
+		if(len == 0)
+			continue;
+
+		if(*starts == '^') {
+			starts++;
+			len--;
+			include = 0;
+		} else if(str) {
+			/* if first token is including, we unselect all targets */
+			memset(array, 0, count);
+		}
+
+		if(len > 1) {
+			/* check for range */
+			char *p;
+			if((p = strchr(starts + 1, '-'))) {
+				*p = 0;
+				ends = p + 1;
+			}
+		}
+
+		if(parseindex(starts, &start, 1, count) != 0)
+			return -1;
+
+		if(!ends) {
+			array[start-1] = include;
+		} else {
+			int d;
+			if(parseindex(ends, &end, start, count) != 0) {
+				return -1;
+			}
+			for(d = start; d <= end; d++) {
+				array[d-1] = include;
+			}
+		}
+	}
+
+	return 0;
+}
+
+int multiselect_question(char *array, int count)
+{
+	char *response, *lastchar;
+	FILE *stream;
+	size_t response_len = 64;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	response = malloc(response_len);
+	if(!response) {
+		return -1;
+	}
+	lastchar = response + response_len - 1;
+	/* sentinel byte to later see if we filled up the entire string */
+	*lastchar = 1;
+
+	while(1) {
+		memset(array, 1, count);
+
+		fprintf(stream, "\n");
+		fprintf(stream, _("Enter a selection (default=all)"));
+		fprintf(stream,	": ");
+		fflush(stream);
+
+		if(config->noconfirm) {
+			fprintf(stream, "\n");
+			break;
+		}
+
+		flush_term_input();
+
+		if(fgets(response, response_len, stdin)) {
+			const size_t response_incr = 64;
+			/* handle buffer not being large enough to read full line case */
+			while(*lastchar == '\0' && lastchar[-1] != '\n') {
+				response_len += response_incr;
+				response = realloc(response, response_len);
+				if(!response) {
+					return -1;
+				}
+				lastchar = response + response_len - 1;
+				/* sentinel byte */
+				*lastchar = 1;
+				if(fgets(response + response_len - response_incr - 1,
+							response_incr + 1, stdin) == 0) {
+					free(response);
+					return -1;
+				}
+			}
+			strtrim(response);
+			if(strlen(response) > 0) {
+				if(multiselect_parse(array, count, response) == -1) {
+					/* only loop if user gave an invalid answer */
+					continue;
+				}
+			}
+			break;
+		} else {
+			free(response);
+			return -1;
+		}
+	}
+
+	free(response);
+	return 0;
+}
+
+int select_question(int count)
+{
+	char response[32];
+	FILE *stream;
+	int preset = 1;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	while(1) {
+		fprintf(stream, "\n");
+		fprintf(stream, _("Enter a number (default=%d)"), preset);
+		fprintf(stream,	": ");
+
+		if(config->noconfirm) {
+			fprintf(stream, "\n");
+			break;
+		}
+
+		flush_term_input();
+
+		if(fgets(response, sizeof(response), stdin)) {
+			strtrim(response);
+			if(strlen(response) > 0) {
+				int n;
+				if(parseindex(response, &n, 1, count) != 0)
+					continue;
+				return (n - 1);
+			}
+		}
+		break;
+	}
+
+	return (preset - 1);
+}
+
+
+/* presents a prompt and gets a Y/N answer */
+static int question(short preset, char *fmt, va_list args)
+{
+	char response[32];
+	FILE *stream;
+
+	if(config->noconfirm) {
+		stream = stdout;
+	} else {
+		/* Use stderr so questions are always displayed when redirecting output */
+		stream = stderr;
+	}
+
+	/* ensure all text makes it to the screen before we prompt the user */
+	fflush(stdout);
+	fflush(stderr);
+
+	vfprintf(stream, fmt, args);
+
+	if(preset) {
+		fprintf(stream, " %s ", _("[Y/n]"));
+	} else {
+		fprintf(stream, " %s ", _("[y/N]"));
+	}
+
+	if(config->noconfirm) {
+		fprintf(stream, "\n");
+		return preset;
+	}
+
+	fflush(stream);
+	flush_term_input();
+
+	if(fgets(response, sizeof(response), stdin)) {
+		strtrim(response);
+		if(strlen(response) == 0) {
+			return preset;
+		}
+
+		/* if stdin is piped, response does not get printed out, and as a result
+		 * a \n is missing, resulting in broken output (FS#27909) */
+		if(!isatty(fileno(stdin))) {
+			fprintf(stream, "%s\n", response);
+		}
+
+		if(strcasecmp(response, _("Y")) == 0 || strcasecmp(response, _("YES")) == 0) {
+			return 1;
+		} else if(strcasecmp(response, _("N")) == 0 || strcasecmp(response, _("NO")) == 0) {
+			return 0;
+		}
+	}
+	return 0;
+}
+
+int yesno(char *fmt, ...)
+{
+	int ret;
+	va_list args;
+
+	va_start(args, fmt);
+	ret = question(1, fmt, args);
+	va_end(args);
+
+	return ret;
+}
+
+int noyes(char *fmt, ...)
+{
+	int ret;
+	va_list args;
+
+	va_start(args, fmt);
+	ret = question(0, fmt, args);
+	va_end(args);
+
+	return ret;
+}
+
+int pm_printf(alpm_loglevel_t level, const char *format, ...)
+{
+	int ret;
+	va_list args;
+
+	/* print the message using va_arg list */
+	va_start(args, format);
+	ret = pm_vfprintf(stderr, level, format, args);
+	va_end(args);
+
+	return ret;
+}
+
+int pm_asprintf(char **string, const char *format, ...)
+{
+	int ret = 0;
+	va_list args;
+
+	/* print the message using va_arg list */
+	va_start(args, format);
+	if(vasprintf(string, format, args) == -1) {
+		pm_printf(ALPM_LOG_ERROR,  _("failed to allocate string\n"));
+		ret = -1;
+	}
+	va_end(args);
+
+	return ret;
+}
+
+int pm_vasprintf(char **string, alpm_loglevel_t level, const char *format, va_list args)
+{
+	int ret = 0;
+	char *msg = NULL;
+
+	/* if current logmask does not overlap with level, do not print msg */
+	if(!(config->logmask & level)) {
+		return ret;
+	}
+
+	/* print the message using va_arg list */
+	ret = vasprintf(&msg, format, args);
+
+	/* print a prefix to the message */
+	switch(level) {
+		case ALPM_LOG_ERROR:
+			pm_asprintf(string, _("error: %s"), msg);
+			break;
+		case ALPM_LOG_WARNING:
+			pm_asprintf(string, _("warning: %s"), msg);
+			break;
+		case ALPM_LOG_DEBUG:
+			pm_asprintf(string, "debug: %s", msg);
+			break;
+		case ALPM_LOG_FUNCTION:
+			pm_asprintf(string, "function: %s", msg);
+			break;
+		default:
+			pm_asprintf(string, "%s", msg);
+			break;
+	}
+	free(msg);
+
+	return ret;
+}
+
+int pm_vfprintf(FILE *stream, alpm_loglevel_t level, const char *format, va_list args)
+{
+	int ret = 0;
+
+	/* if current logmask does not overlap with level, do not print msg */
+	if(!(config->logmask & level)) {
+		return ret;
+	}
+
+#if defined(PACMAN_DEBUG)
+	/* If debug is on, we'll timestamp the output */
+	if(config->logmask & ALPM_LOG_DEBUG) {
+		time_t t;
+		struct tm *tmp;
+		char timestr[10] = {0};
+
+		t = time(NULL);
+		tmp = localtime(&t);
+		strftime(timestr, 9, "%H:%M:%S", tmp);
+		timestr[8] = '\0';
+
+		fprintf(stream, "[%s] ", timestr);
+	}
+#endif
+
+	/* print a prefix to the message */
+	switch(level) {
+		case ALPM_LOG_ERROR:
+			fprintf(stream, _("error: "));
+			break;
+		case ALPM_LOG_WARNING:
+			fprintf(stream, _("warning: "));
+			break;
+		case ALPM_LOG_DEBUG:
+			fprintf(stream, "debug: ");
+			break;
+		case ALPM_LOG_FUNCTION:
+			fprintf(stream, "function: ");
+			break;
+		default:
+			break;
+	}
+
+	/* print the message using va_arg list */
+	ret = vfprintf(stream, format, args);
+	return ret;
+}
+
+#ifndef HAVE_STRNDUP
+/* A quick and dirty implementation derived from glibc */
+static size_t strnlen(const char *s, size_t max)
+{
+    register const char *p;
+    for(p = s; *p && max--; ++p);
+    return (p - s);
+}
+
+char *strndup(const char *s, size_t n)
+{
+  size_t len = strnlen(s, n);
+  char *new = (char *) malloc(len + 1);
+
+  if(new == NULL)
+    return NULL;
+
+  new[len] = '\0';
+  return (char *)memcpy(new, s, len);
+}
+#endif
+
+/* vim: set ts=2 sw=2 noet: */
diff -Npaur a/src/pacman/util.h b/src/pacman/util.h
--- a/src/pacman/util.h	2012-02-03 16:56:16.000000000 +0200
+++ b/src/pacman/util.h	2012-04-11 18:51:00.948480616 +0300
@@ -45,6 +45,48 @@ typedef struct _pm_target_t {
 	int is_explicit;
 } pm_target_t;
 
+/* pacman-color */
+typedef enum _separator_t {
+	SEP_ANY = 0,
+	SEP_LINE,
+	SEP_COLON,
+} separator_t;
+
+typedef enum _color_t {
+	COLOR_END = 0,
+	COLOR_SAME,
+	COLOR_RED,
+	COLOR_GREEN,
+	COLOR_YELLOW,
+	COLOR_BLUE,
+	COLOR_MAGENTA,
+	COLOR_CYAN,
+	COLOR_WHITE,
+	COLOR_NONE,
+} color_t;
+
+typedef struct _colordata_t {
+	separator_t separator;
+	color_t color;
+} colordata_t;
+
+extern const colordata_t COLOR_WHITE_ALL[];
+extern const colordata_t COLOR_GREEN_ALL[];
+extern const colordata_t COLOR_RED_ALL[];
+extern const colordata_t COLOR_BLUE_ALL[];
+extern const colordata_t COLOR_YELLOW_ALL[];
+extern const colordata_t COLOR_MAGENTA_ALL[];
+extern const colordata_t COLOR_CYAN_ALL[];
+extern const colordata_t COLOR_DOUBLECOLON[];
+extern const colordata_t COLOR_DOUBLECOLON2[];
+extern const colordata_t COLOR_WHITE_COLON[];
+
+int parsecolorconfig();
+int color_fprintf(FILE* stream, const colordata_t* colors, const char* format, ...) __attribute__((format(printf,3,4)));
+int color_printf(const colordata_t* colors, const char* format, ...) __attribute__((format(printf,2,3)));
+int color_vfprintf(FILE* stream, const colordata_t* colors, const char* format, va_list args) __attribute__((format(printf,3,0)));
+void color_string_display(const colordata_t* colors_title, const char* title, const colordata_t* colors_string, const char* string);
+
 void trans_init_error(void);
 int trans_init(alpm_transflag_t flags, int check_valid);
 int trans_release(void);
@@ -58,12 +100,12 @@ void indentprint(const char *str, size_t
 char *strtrim(char *str);
 char *strreplace(const char *str, const char *needle, const char *replace);
 alpm_list_t *strsplit(const char *str, const char splitchar);
-void string_display(const char *title, const char *string);
+void string_display(const colordata_t *colors_title, const char *title, const char *string);
 double humanize_size(off_t bytes, const char target_unit, int precision,
 		const char **label);
 int table_display(const char *title, const alpm_list_t *header, const alpm_list_t *rows);
-void list_display(const char *title, const alpm_list_t *list);
-void list_display_linebreak(const char *title, const alpm_list_t *list);
+void list_display(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
+void list_display_linebreak(const colordata_t *colors_title, const char *title, const alpm_list_t *list);
 void signature_display(const char *title, alpm_siglist_t *siglist);
 void display_targets(void);
 int str_cmp(const void *s1, const void *s2);
@@ -73,8 +115,8 @@ void print_packages(const alpm_list_t *p
 void select_display(const alpm_list_t *pkglist);
 int select_question(int count);
 int multiselect_question(char *array, int count);
-int yesno(char *fmt, ...);
-int noyes(char *fmt, ...);
+int yesno(const colordata_t *colors, char *fmt, ...);
+int noyes(const colordata_t *colors, char *fmt, ...);
 
 int pm_printf(alpm_loglevel_t level, const char *format, ...) __attribute__((format(printf,2,3)));
 int pm_asprintf(char **string, const char *format, ...);
